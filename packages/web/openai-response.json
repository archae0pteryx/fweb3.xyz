{
  status: 200,
  statusText: "OK",
  headers: {
    date: "Wed, 14 Dec 2022 05:06:49 GMT",
    "content-type": "application/json",
    "content-length": "1534",
    connection: "close",
    "access-control-allow-origin": "*",
    "cache-control": "no-cache, must-revalidate",
    "openai-model": "text-davinci-003",
    "openai-organization": "user-1qbprpgzlifvfzl2glfbtst9",
    "openai-processing-ms": "5807",
    "openai-version": "2020-10-01",
    "strict-transport-security": "max-age=15724800; includeSubDomains",
    "x-request-id": "50e9d04aae04a3b099d8630fb222d2ca",
  },
  config: {
    transitional: {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false,
    },
    adapter: function httpAdapter(config) {
      return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) {
        var onCanceled;
        function done() {
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(onCanceled);
          }

          if (config.signal) {
            config.signal.removeEventListener('abort', onCanceled);
          }
        }
        var resolve = function resolve(value) {
          done();
          resolvePromise(value);
        };
        var rejected = false;
        var reject = function reject(value) {
          done();
          rejected = true;
          rejectPromise(value);
        };
        var data = config.data;
        var headers = config.headers;
        var headerNames = {};

        Object.keys(headers).forEach(function storeLowerName(name) {
          headerNames[name.toLowerCase()] = name;
        });

        // Set User-Agent (required by some servers)
        // See https://github.com/axios/axios/issues/69
        if ('user-agent' in headerNames) {
          // User-Agent is specified; handle case where no UA header is desired
          if (!headers[headerNames['user-agent']]) {
            delete headers[headerNames['user-agent']];
          }
          // Otherwise, use specified value
        } else {
          // Only set header if it hasn't been set in config
          headers['User-Agent'] = 'axios/' + VERSION;
        }

        if (data && !utils.isStream(data)) {
          if (Buffer.isBuffer(data)) {
            // Nothing to do...
          } else if (utils.isArrayBuffer(data)) {
            data = Buffer.from(new Uint8Array(data));
          } else if (utils.isString(data)) {
            data = Buffer.from(data, 'utf-8');
          } else {
            return reject(createError(
              'Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream',
              config
            ));
          }

          if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {
            return reject(createError('Request body larger than maxBodyLength limit', config));
          }

          // Add Content-Length header if data exists
          if (!headerNames['content-length']) {
            headers['Content-Length'] = data.length;
          }
        }

        // HTTP basic authentication
        var auth = undefined;
        if (config.auth) {
          var username = config.auth.username || '';
          var password = config.auth.password || '';
          auth = username + ':' + password;
        }

        // Parse url
        var fullPath = buildFullPath(config.baseURL, config.url);
        var parsed = url.parse(fullPath);
        var protocol = parsed.protocol || 'http:';

        if (!auth && parsed.auth) {
          var urlAuth = parsed.auth.split(':');
          var urlUsername = urlAuth[0] || '';
          var urlPassword = urlAuth[1] || '';
          auth = urlUsername + ':' + urlPassword;
        }

        if (auth && headerNames.authorization) {
          delete headers[headerNames.authorization];
        }

        var isHttpsRequest = isHttps.test(protocol);
        var agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;

        try {
          buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\?/, '');
        } catch (err) {
          var customErr = new Error(err.message);
          customErr.config = config;
          customErr.url = config.url;
          customErr.exists = true;
          reject(customErr);
        }

        var options = {
          path: buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\?/, ''),
          method: config.method.toUpperCase(),
          headers: headers,
          agent: agent,
          agents: { http: config.httpAgent, https: config.httpsAgent },
          auth: auth
        };

        if (config.socketPath) {
          options.socketPath = config.socketPath;
        } else {
          options.hostname = parsed.hostname;
          options.port = parsed.port;
        }

        var proxy = config.proxy;
        if (!proxy && proxy !== false) {
          var proxyEnv = protocol.slice(0, -1) + '_proxy';
          var proxyUrl = process.env[proxyEnv] || process.env[proxyEnv.toUpperCase()];
          if (proxyUrl) {
            var parsedProxyUrl = url.parse(proxyUrl);
            var noProxyEnv = process.env.no_proxy || process.env.NO_PROXY;
            var shouldProxy = true;

            if (noProxyEnv) {
              var noProxy = noProxyEnv.split(',').map(function trim(s) {
                return s.trim();
              });

              shouldProxy = !noProxy.some(function proxyMatch(proxyElement) {
                if (!proxyElement) {
                  return false;
                }
                if (proxyElement === '*') {
                  return true;
                }
                if (proxyElement[0] === '.' &&
                    parsed.hostname.substr(parsed.hostname.length - proxyElement.length) === proxyElement) {
                  return true;
                }

                return parsed.hostname === proxyElement;
              });
            }

            if (shouldProxy) {
              proxy = {
                host: parsedProxyUrl.hostname,
                port: parsedProxyUrl.port,
                protocol: parsedProxyUrl.protocol
              };

              if (parsedProxyUrl.auth) {
                var proxyUrlAuth = parsedProxyUrl.auth.split(':');
                proxy.auth = {
                  username: proxyUrlAuth[0],
                  password: proxyUrlAuth[1]
                };
              }
            }
          }
        }

        if (proxy) {
          options.headers.host = parsed.hostname + (parsed.port ? ':' + parsed.port : '');
          setProxy(options, proxy, protocol + '//' + parsed.hostname + (parsed.port ? ':' + parsed.port : '') + options.path);
        }

        var transport;
        var isHttpsProxy = isHttpsRequest && (proxy ? isHttps.test(proxy.protocol) : true);
        if (config.transport) {
          transport = config.transport;
        } else if (config.maxRedirects === 0) {
          transport = isHttpsProxy ? https : http;
        } else {
          if (config.maxRedirects) {
            options.maxRedirects = config.maxRedirects;
          }
          transport = isHttpsProxy ? httpsFollow : httpFollow;
        }

        if (config.maxBodyLength > -1) {
          options.maxBodyLength = config.maxBodyLength;
        }

        if (config.insecureHTTPParser) {
          options.insecureHTTPParser = config.insecureHTTPParser;
        }

        // Create the request
        var req = transport.request(options, function handleResponse(res) {
          if (req.aborted) return;

          // uncompress the response body transparently if required
          var stream = res;

          // return the last request in case of redirects
          var lastRequest = res.req || req;


          // if no content, is HEAD request or decompress disabled we should not decompress
          if (res.statusCode !== 204 && lastRequest.method !== 'HEAD' && config.decompress !== false) {
            switch (res.headers['content-encoding']) {
            /*eslint default-case:0*/
            case 'gzip':
            case 'compress':
            case 'deflate':
            // add the unzipper to the body stream processing pipeline
              stream = stream.pipe(zlib.createUnzip());

              // remove the content-encoding in order to not confuse downstream operations
              delete res.headers['content-encoding'];
              break;
            }
          }

          var response = {
            status: res.statusCode,
            statusText: res.statusMessage,
            headers: res.headers,
            config: config,
            request: lastRequest
          };

          if (config.responseType === 'stream') {
            response.data = stream;
            settle(resolve, reject, response);
          } else {
            var responseBuffer = [];
            var totalResponseBytes = 0;
            stream.on('data', function handleStreamData(chunk) {
              responseBuffer.push(chunk);
              totalResponseBytes += chunk.length;

              // make sure the content length is not over the maxContentLength if specified
              if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
                // stream.destoy() emit aborted event before calling reject() on Node.js v16
                rejected = true;
                stream.destroy();
                reject(createError('maxContentLength size of ' + config.maxContentLength + ' exceeded',
                  config, null, lastRequest));
              }
            });

            stream.on('aborted', function handlerStreamAborted() {
              if (rejected) {
                return;
              }
              stream.destroy();
              reject(createError('error request aborted', config, 'ERR_REQUEST_ABORTED', lastRequest));
            });

            stream.on('error', function handleStreamError(err) {
              if (req.aborted) return;
              reject(enhanceError(err, config, null, lastRequest));
            });

            stream.on('end', function handleStreamEnd() {
              try {
                var responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
                if (config.responseType !== 'arraybuffer') {
                  responseData = responseData.toString(config.responseEncoding);
                  if (!config.responseEncoding || config.responseEncoding === 'utf8') {
                    responseData = utils.stripBOM(responseData);
                  }
                }
                response.data = responseData;
              } catch (err) {
                reject(enhanceError(err, config, err.code, response.request, response));
              }
              settle(resolve, reject, response);
            });
          }
        });

        // Handle errors
        req.on('error', function handleRequestError(err) {
          if (req.aborted && err.code !== 'ERR_FR_TOO_MANY_REDIRECTS') return;
          reject(enhanceError(err, config, null, req));
        });

        // set tcp keep alive to prevent drop connection by peer
        req.on('socket', function handleRequestSocket(socket) {
          // default interval of sending ack packet is 1 minute
          socket.setKeepAlive(true, 1000 * 60);
        });

        // Handle request timeout
        if (config.timeout) {
          // This is forcing a int timeout to avoid problems if the `req` interface doesn't handle other types.
          var timeout = parseInt(config.timeout, 10);

          if (isNaN(timeout)) {
            reject(createError(
              'error trying to parse `config.timeout` to int',
              config,
              'ERR_PARSE_TIMEOUT',
              req
            ));

            return;
          }

          // Sometime, the response will be very slow, and does not respond, the connect event will be block by event loop system.
          // And timer callback will be fired, and abort() will be invoked before connection, then get "socket hang up" and code ECONNRESET.
          // At this time, if we have a large number of request, nodejs will hang up some socket on background. and the number will up and up.
          // And then these socket which be hang up will devoring CPU little by little.
          // ClientRequest.setTimeout will be fired on the specify milliseconds, and can make sure that abort() will be fired after connect.
          req.setTimeout(timeout, function handleRequestTimeout() {
            req.abort();
            var timeoutErrorMessage = '';
            if (config.timeoutErrorMessage) {
              timeoutErrorMessage = config.timeoutErrorMessage;
            } else {
              timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';
            }
            var transitional = config.transitional || transitionalDefaults;
            reject(createError(
              timeoutErrorMessage,
              config,
              transitional.clarifyTimeoutError ? 'ETIMEDOUT' : 'ECONNABORTED',
              req
            ));
          });
        }

        if (config.cancelToken || config.signal) {
          // Handle cancellation
          // eslint-disable-next-line func-names
          onCanceled = function(cancel) {
            if (req.aborted) return;

            req.abort();
            reject(!cancel || (cancel && cancel.type) ? new Cancel('canceled') : cancel);
          };

          config.cancelToken && config.cancelToken.subscribe(onCanceled);
          if (config.signal) {
            config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);
          }
        }


        // Send the request
        if (utils.isStream(data)) {
          data.on('error', function handleStreamError(err) {
            reject(enhanceError(err, config, null, req));
          }).pipe(req);
        } else {
          req.end(data);
        }
      });
    },
    transformRequest: [
      function transformRequest(data, headers) {
        normalizeHeaderName(headers, 'Accept');
        normalizeHeaderName(headers, 'Content-Type');

        if (utils.isFormData(data) ||
          utils.isArrayBuffer(data) ||
          utils.isBuffer(data) ||
          utils.isStream(data) ||
          utils.isFile(data) ||
          utils.isBlob(data)
        ) {
          return data;
        }
        if (utils.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
          return data.toString();
        }
        if (utils.isObject(data) || (headers && headers['Content-Type'] === 'application/json')) {
          setContentTypeIfUnset(headers, 'application/json');
          return stringifySafely(data);
        }
        return data;
      },
    ],
    transformResponse: [
      function transformResponse(data) {
        var transitional = this.transitional || defaults.transitional;
        var silentJSONParsing = transitional && transitional.silentJSONParsing;
        var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';

        if (strictJSONParsing || (forcedJSONParsing && utils.isString(data) && data.length)) {
          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === 'SyntaxError') {
                throw enhanceError(e, this, 'E_JSON_PARSE');
              }
              throw e;
            }
          }
        }

        return data;
      },
    ],
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    validateStatus: function validateStatus(status) {
      return status >= 200 && status < 300;
    },
    headers: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": "application/json",
      "User-Agent": "OpenAI/NodeJS/3.1.0",
      Authorization: "Bearer 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",
      "Content-Length": 342,
    },
    method: "post",
    data: "{\"model\":\"text-davinci-003\",\"prompt\":\"Write a markdown formatted page describing the importance of onboarding people into the web3 space. Include bullet points explaining the benefits of the technology. Explain that you will learn how to properly connect a wallet and what an NFT is by playing this game.\",\"temperature\":0.9,\"max_tokens\":1024}",
    url: "https://api.openai.com/v1/completions",
  },
  request: {
    _events: {
      abort: function (arg1, arg2, arg3) {
        this._redirectable.emit(event, arg1, arg2, arg3);
      },
      aborted: function (arg1, arg2, arg3) {
        this._redirectable.emit(event, arg1, arg2, arg3);
      },
      connect: function (arg1, arg2, arg3) {
        this._redirectable.emit(event, arg1, arg2, arg3);
      },
      error: function (arg1, arg2, arg3) {
        this._redirectable.emit(event, arg1, arg2, arg3);
      },
      socket: function (arg1, arg2, arg3) {
        this._redirectable.emit(event, arg1, arg2, arg3);
      },
      timeout: function (arg1, arg2, arg3) {
        this._redirectable.emit(event, arg1, arg2, arg3);
      },
      prefinish: function requestOnPrefinish() {
        const req = this;

        if (req.shouldKeepAlive && req._ended)
          responseKeepAlive(req);
      },
    },
    _eventsCount: 7,
    _maxListeners: undefined,
    outputData: [
    ],
    outputSize: 0,
    writable: true,
    destroyed: false,
    _last: true,
    chunkedEncoding: false,
    shouldKeepAlive: false,
    maxRequestsOnConnectionReached: false,
    _defaultKeepAlive: true,
    useChunkedEncodingByDefault: true,
    sendDate: false,
    _removedConnection: false,
    _removedContLen: false,
    _removedTE: false,
    _contentLength: null,
    _hasBody: true,
    _trailer: "",
    finished: true,
    _headerSent: true,
    _closed: false,
    socket: {
      _tlsOptions: {
        allowHalfOpen: undefined,
        pipe: false,
        secureContext: {
          context: {
          },
        },
        isServer: false,
        requestCert: true,
        rejectUnauthorized: true,
        session: undefined,
        ALPNProtocols: undefined,
        requestOCSP: undefined,
        enableTrace: undefined,
        pskCallback: undefined,
        highWaterMark: undefined,
        onread: undefined,
        signal: undefined,
      },
      _secureEstablished: true,
      _securePending: false,
      _newSessionPending: false,
      _controlReleased: true,
      secureConnecting: false,
      _SNICallback: null,
      servername: "api.openai.com",
      alpnProtocol: false,
      authorized: true,
      authorizationError: null,
      encrypted: true,
      _events: {
        close: [
          function onSocketCloseDestroySSL() {
            // Make sure we are not doing it on OpenSSL's stack
            setImmediate(destroySSL, this);
            this[kRes] = null;
          },
          function () { [native code] },
          function onClose(err) {
            debug('CLIENT socket onClose');
            // This is the only place where sockets get removed from the Agent.
            // If you want to remove a socket from the pool, just close it.
            // All socket errors end in a close event anyway.
            agent.totalSocketCount--;
            agent.removeSocket(s, options);
          },
          function socketCloseListener() {
            const socket = this;
            const req = socket._httpMessage;
            debug('HTTP socket close');

            // NOTE: It's important to get parser here, because it could be freed by
            // the `socketOnData`.
            const parser = socket.parser;
            const res = req.res;

            req.destroyed = true;
            if (res) {
              // Socket closed before we emitted 'end' below.
              if (!res.complete) {
                res.destroy(connResetException('aborted'));
              }
              req._closed = true;
              req.emit('close');
              if (!res.aborted && res.readable) {
                res.push(null);
              }
            } else {
              if (!req.socket._hadError) {
                // This socket error fired before we started to
                // receive a response. The error needs to
                // fire on the request.
                req.socket._hadError = true;
                req.emit('error', connResetException('socket hang up'));
              }
              req._closed = true;
              req.emit('close');
            }

            // Too bad.  That output wasn't getting written.
            // This is pretty terrible that it doesn't raise an error.
            // Fixed better in v0.10
            if (req.outputData)
              req.outputData.length = 0;

            if (parser) {
              parser.finish();
              freeParser(parser, req, socket);
            }
          },
        ],
        end: function onReadableStreamEnd() {
          if (!this.allowHalfOpen) {
            this.write = writeAfterFIN;
          }
        },
        newListener: function keylogNewListener(event) {
          if (event !== 'keylog')
            return;

          // Guard against enableKeylogCallback after destroy
          if (!this._handle) return;
          this._handle.enableKeylogCallback();

          // Remove this listener since it's no longer needed.
          this.removeListener('newListener', keylogNewListener);
        },
        secure: function onConnectSecure() {
          const options = this[kConnectOptions];

          // Check the size of DHE parameter above minimum requirement
          // specified in options.
          const ekeyinfo = this.getEphemeralKeyInfo();
          if (ekeyinfo.type === 'DH' && ekeyinfo.size < options.minDHSize) {
            const err = new ERR_TLS_DH_PARAM_SIZE(ekeyinfo.size);
            debug('client emit:', err);
            this.emit('error', err);
            this.destroy();
            return;
          }

          let verifyError = this._handle.verifyError();

          // Verify that server's identity matches it's certificate's names
          // Unless server has resumed our existing session
          if (!verifyError && !this.isSessionReused()) {
            const hostname = options.servername ||
                           options.host ||
                           (options.socket && options.socket._host) ||
                           'localhost';
            const cert = this.getPeerCertificate(true);
            verifyError = options.checkServerIdentity(hostname, cert);
          }

          if (verifyError) {
            this.authorized = false;
            this.authorizationError = verifyError.code || verifyError.message;

            // rejectUnauthorized property can be explicitly defined as `undefined`
            // causing the assignment to default value (`true`) fail. Before assigning
            // it to the tlssock connection options, explicitly check if it is false
            // and update rejectUnauthorized property. The property gets used by
            // TLSSocket connection handler to allow or reject connection if
            // unauthorized.
            // This check is potentially redundant, however it is better to keep it
            // in case the option object gets modified somewhere.
            if (options.rejectUnauthorized !== false) {
              this.destroy(verifyError);
              return;
            }
            debug('client emit secureConnect. rejectUnauthorized: %s, ' +
                  'authorizationError: %s', options.rejectUnauthorized,
                  this.authorizationError);
            this.secureConnecting = false;
            this.emit('secureConnect');
          } else {
            this.authorized = true;
            debug('client emit secureConnect. authorized:', this.authorized);
            this.secureConnecting = false;
            this.emit('secureConnect');
          }

          this[kIsVerified] = true;
          const session = this[kPendingSession];
          this[kPendingSession] = null;
          if (session)
            this.emit('session', session);

          this.removeListener('end', onConnectEnd);
        },
        session: (session) => {
          this._cacheSession(options._agentKey, session);
        },
        free: function onFree() {
          debug('CLIENT socket onFree');
          agent.emit('free', s, options);
        },
        timeout: function onTimeout() {
          debug('CLIENT socket onTimeout');

          // Destroy if in free list.
          // TODO(ronag): Always destroy, even if not in free list.
          const sockets = agent.freeSockets;
          if (ArrayPrototypeSome(ObjectKeys(sockets), (name) =>
            ArrayPrototypeIncludes(sockets[name], s)
          )) {
            return s.destroy();
          }
        },
        agentRemove: function onRemove() {
          // We need this function for cases like HTTP 'upgrade'
          // (defined by WebSockets) where we need to remove a socket from the
          // pool because it'll be locked up indefinitely
          debug('CLIENT socket onRemove');
          agent.totalSocketCount--;
          agent.removeSocket(s, options);
          s.removeListener('close', onClose);
          s.removeListener('free', onFree);
          s.removeListener('timeout', onTimeout);
          s.removeListener('agentRemove', onRemove);
        },
        error: function socketErrorListener(err) {
          const socket = this;
          const req = socket._httpMessage;
          debug('SOCKET ERROR:', err.message, err.stack);

          if (req) {
            // For Safety. Some additional errors might fire later on
            // and we need to make sure we don't double-fire the error event.
            req.socket._hadError = true;
            req.emit('error', err);
          }

          const parser = socket.parser;
          if (parser) {
            parser.finish();
            freeParser(parser, req, socket);
          }

          // Ensure that no further data will come out of the socket
          socket.removeListener('data', socketOnData);
          socket.removeListener('end', socketOnEnd);
          socket.destroy();
        },
        finish: function () { [native code] },
      },
      _eventsCount: 10,
      connecting: false,
      _hadError: false,
      _parent: null,
      _host: "api.openai.com",
      _readableState: {
        objectMode: false,
        highWaterMark: 16384,
        buffer: {
          head: null,
          tail: null,
          length: 0,
        },
        length: 0,
        pipes: [
        ],
        flowing: true,
        ended: false,
        endEmitted: false,
        reading: true,
        constructed: true,
        sync: false,
        needReadable: true,
        emittedReadable: false,
        readableListening: false,
        resumeScheduled: false,
        errorEmitted: false,
        emitClose: false,
        autoDestroy: true,
        destroyed: false,
        errored: null,
        closed: false,
        closeEmitted: false,
        defaultEncoding: "utf8",
        awaitDrainWriters: null,
        multiAwaitDrain: false,
        readingMore: false,
        dataEmitted: true,
        decoder: null,
        encoding: null,
      },
      _maxListeners: undefined,
      _writableState: {
        objectMode: false,
        highWaterMark: 16384,
        finalCalled: true,
        needDrain: false,
        ending: true,
        ended: true,
        finished: false,
        destroyed: false,
        decodeStrings: false,
        defaultEncoding: "utf8",
        length: 0,
        writing: false,
        corked: 0,
        sync: false,
        bufferProcessing: false,
        onwrite: function () { [native code] },
        writecb: null,
        writelen: 0,
        afterWriteTickInfo: null,
        buffered: [
        ],
        bufferedIndex: 0,
        allBuffers: true,
        allNoop: true,
        pendingcb: 1,
        constructed: true,
        prefinished: false,
        errorEmitted: false,
        emitClose: false,
        autoDestroy: true,
        errored: null,
        closed: false,
        closeEmitted: false,
      },
      allowHalfOpen: false,
      _sockname: null,
      _pendingData: null,
      _pendingEncoding: "",
      server: undefined,
      _server: null,
      ssl: {
        _parent: {
          reading: true,
          onconnection: null,
        },
        _parentWrap: undefined,
        _secureContext: {
          context: {
          },
        },
        reading: true,
        onkeylog: function onkeylog(line) {
          debug('onkeylog');
          this[owner_symbol].emit('keylog', line);
        },
        onhandshakestart: function () { [native code] },
        onhandshakedone: () => {
          debug('client onhandshakedone');
          this._finishInit();
        },
        onocspresponse: function onocspresponse(resp) {
          debug('client onocspresponse');
          this[owner_symbol].emit('OCSPResponse', resp);
        },
        onnewsession: function onnewsessionclient(sessionId, session) {
          debug('client emit session');
          const owner = this[owner_symbol];
          if (owner[kIsVerified]) {
            owner.emit('session', session);
          } else {
            owner[kPendingSession] = session;
          }
        },
        onerror: function onerror(err) {
          const owner = this[owner_symbol];
          debug('%s onerror %s had? %j',
                (typeof owner._tlsOptions === 'object' && owner._tlsOptions !== null) ?
                  owner._tlsOptions.isServer ? 'server' : 'client' :
                  'unknown',
                err, owner._hadError);

          if (owner._hadError)
            return;

          owner._hadError = true;

          // Destroy socket if error happened before handshake's finish
          if (!owner._secureEstablished) {
            // When handshake fails control is not yet released,
            // so self._tlsError will return null instead of actual error
            owner.destroy(err);
          } else if (owner._tlsOptions?.isServer &&
                     owner._rejectUnauthorized &&
                     RegExpPrototypeTest(/peer did not return a certificate/,
                                         err.message)) {
            // Ignore server's authorization errors
            owner.destroy();
          } else {
            // Emit error
            owner._emitTLSError(err);
          }
        },
      },
      _requestCert: true,
      _rejectUnauthorized: true,
      parser: null,
      _httpMessage: [Circular],
    },
    _header: "POST /v1/completions HTTP/1.1\r\nAccept: application/json, text/plain, */*\r\nContent-Type: application/json\r\nUser-Agent: OpenAI/NodeJS/3.1.0\r\nAuthorization: Bearer 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\r\nContent-Length: 342\r\nHost: api.openai.com\r\nConnection: close\r\n\r\n",
    _keepAliveTimeout: 0,
    _onPendingData: () => {},
    agent: {
      _events: {
        free: (socket, options) => {
          const name = this.getName(options);
          debug('agent.on(free)', name);

          // TODO(ronag): socket.destroy(err) might have been called
          // before coming here and have an 'error' scheduled. In the
          // case of socket.destroy() below this 'error' has no handler
          // and could cause unhandled exception.

          if (!socket.writable) {
            socket.destroy();
            return;
          }

          const requests = this.requests[name];
          if (requests && requests.length) {
            const req = ArrayPrototypeShift(requests);
            const reqAsyncRes = req[kRequestAsyncResource];
            if (reqAsyncRes) {
              // Run request within the original async context.
              reqAsyncRes.runInAsyncScope(() => {
                asyncResetHandle(socket);
                setRequestSocket(this, req, socket);
              });
              req[kRequestAsyncResource] = null;
            } else {
              setRequestSocket(this, req, socket);
            }
            if (requests.length === 0) {
              delete this.requests[name];
            }
            return;
          }

          // If there are no pending requests, then put it in
          // the freeSockets pool, but only if we're allowed to do so.
          const req = socket._httpMessage;
          if (!req || !req.shouldKeepAlive || !this.keepAlive) {
            socket.destroy();
            return;
          }

          const freeSockets = this.freeSockets[name] || [];
          const freeLen = freeSockets.length;
          let count = freeLen;
          if (this.sockets[name])
            count += this.sockets[name].length;

          if (this.totalSocketCount > this.maxTotalSockets ||
              count > this.maxSockets ||
              freeLen >= this.maxFreeSockets ||
              !this.keepSocketAlive(socket)) {
            socket.destroy();
            return;
          }

          this.freeSockets[name] = freeSockets;
          socket[async_id_symbol] = -1;
          socket._httpMessage = null;
          this.removeSocket(socket, options);

          socket.once('error', freeSocketErrorListener);
          ArrayPrototypePush(freeSockets, socket);
        },
        newListener: function maybeEnableKeylog(eventName) {
          if (eventName === 'keylog') {
            this.removeListener('newListener', maybeEnableKeylog);
            // Future sockets will listen on keylog at creation.
            const agent = this;
            this[kOnKeylog] = function onkeylog(keylog) {
              agent.emit('keylog', keylog, this);
            };
            // Existing sockets will start listening on keylog now.
            const sockets = ObjectValues(this.sockets);
            for (let i = 0; i < sockets.length; i++) {
              sockets[i].on('keylog', this[kOnKeylog]);
            }
          }
        },
      },
      _eventsCount: 2,
      _maxListeners: undefined,
      defaultPort: 443,
      protocol: "https:",
      options: {
        path: null,
      },
      requests: {
      },
      sockets: {
        "api.openai.com:443:::::::::::::::::::::": [
          {
            _tlsOptions: {
              allowHalfOpen: undefined,
              pipe: false,
              secureContext: {
                context: {
                },
              },
              isServer: false,
              requestCert: true,
              rejectUnauthorized: true,
              session: undefined,
              ALPNProtocols: undefined,
              requestOCSP: undefined,
              enableTrace: undefined,
              pskCallback: undefined,
              highWaterMark: undefined,
              onread: undefined,
              signal: undefined,
            },
            _secureEstablished: true,
            _securePending: false,
            _newSessionPending: false,
            _controlReleased: true,
            secureConnecting: false,
            _SNICallback: null,
            servername: "api.openai.com",
            alpnProtocol: false,
            authorized: true,
            authorizationError: null,
            encrypted: true,
            _events: {
              close: [
                function onSocketCloseDestroySSL() {
                  // Make sure we are not doing it on OpenSSL's stack
                  setImmediate(destroySSL, this);
                  this[kRes] = null;
                },
                function () { [native code] },
                function onClose(err) {
                  debug('CLIENT socket onClose');
                  // This is the only place where sockets get removed from the Agent.
                  // If you want to remove a socket from the pool, just close it.
                  // All socket errors end in a close event anyway.
                  agent.totalSocketCount--;
                  agent.removeSocket(s, options);
                },
                function socketCloseListener() {
                  const socket = this;
                  const req = socket._httpMessage;
                  debug('HTTP socket close');

                  // NOTE: It's important to get parser here, because it could be freed by
                  // the `socketOnData`.
                  const parser = socket.parser;
                  const res = req.res;

                  req.destroyed = true;
                  if (res) {
                    // Socket closed before we emitted 'end' below.
                    if (!res.complete) {
                      res.destroy(connResetException('aborted'));
                    }
                    req._closed = true;
                    req.emit('close');
                    if (!res.aborted && res.readable) {
                      res.push(null);
                    }
                  } else {
                    if (!req.socket._hadError) {
                      // This socket error fired before we started to
                      // receive a response. The error needs to
                      // fire on the request.
                      req.socket._hadError = true;
                      req.emit('error', connResetException('socket hang up'));
                    }
                    req._closed = true;
                    req.emit('close');
                  }

                  // Too bad.  That output wasn't getting written.
                  // This is pretty terrible that it doesn't raise an error.
                  // Fixed better in v0.10
                  if (req.outputData)
                    req.outputData.length = 0;

                  if (parser) {
                    parser.finish();
                    freeParser(parser, req, socket);
                  }
                },
              ],
              end: function onReadableStreamEnd() {
                if (!this.allowHalfOpen) {
                  this.write = writeAfterFIN;
                }
              },
              newListener: function keylogNewListener(event) {
                if (event !== 'keylog')
                  return;

                // Guard against enableKeylogCallback after destroy
                if (!this._handle) return;
                this._handle.enableKeylogCallback();

                // Remove this listener since it's no longer needed.
                this.removeListener('newListener', keylogNewListener);
              },
              secure: function onConnectSecure() {
                const options = this[kConnectOptions];

                // Check the size of DHE parameter above minimum requirement
                // specified in options.
                const ekeyinfo = this.getEphemeralKeyInfo();
                if (ekeyinfo.type === 'DH' && ekeyinfo.size < options.minDHSize) {
                  const err = new ERR_TLS_DH_PARAM_SIZE(ekeyinfo.size);
                  debug('client emit:', err);
                  this.emit('error', err);
                  this.destroy();
                  return;
                }

                let verifyError = this._handle.verifyError();

                // Verify that server's identity matches it's certificate's names
                // Unless server has resumed our existing session
                if (!verifyError && !this.isSessionReused()) {
                  const hostname = options.servername ||
                                 options.host ||
                                 (options.socket && options.socket._host) ||
                                 'localhost';
                  const cert = this.getPeerCertificate(true);
                  verifyError = options.checkServerIdentity(hostname, cert);
                }

                if (verifyError) {
                  this.authorized = false;
                  this.authorizationError = verifyError.code || verifyError.message;

                  // rejectUnauthorized property can be explicitly defined as `undefined`
                  // causing the assignment to default value (`true`) fail. Before assigning
                  // it to the tlssock connection options, explicitly check if it is false
                  // and update rejectUnauthorized property. The property gets used by
                  // TLSSocket connection handler to allow or reject connection if
                  // unauthorized.
                  // This check is potentially redundant, however it is better to keep it
                  // in case the option object gets modified somewhere.
                  if (options.rejectUnauthorized !== false) {
                    this.destroy(verifyError);
                    return;
                  }
                  debug('client emit secureConnect. rejectUnauthorized: %s, ' +
                        'authorizationError: %s', options.rejectUnauthorized,
                        this.authorizationError);
                  this.secureConnecting = false;
                  this.emit('secureConnect');
                } else {
                  this.authorized = true;
                  debug('client emit secureConnect. authorized:', this.authorized);
                  this.secureConnecting = false;
                  this.emit('secureConnect');
                }

                this[kIsVerified] = true;
                const session = this[kPendingSession];
                this[kPendingSession] = null;
                if (session)
                  this.emit('session', session);

                this.removeListener('end', onConnectEnd);
              },
              session: (session) => {
                this._cacheSession(options._agentKey, session);
              },
              free: function onFree() {
                debug('CLIENT socket onFree');
                agent.emit('free', s, options);
              },
              timeout: function onTimeout() {
                debug('CLIENT socket onTimeout');

                // Destroy if in free list.
                // TODO(ronag): Always destroy, even if not in free list.
                const sockets = agent.freeSockets;
                if (ArrayPrototypeSome(ObjectKeys(sockets), (name) =>
                  ArrayPrototypeIncludes(sockets[name], s)
                )) {
                  return s.destroy();
                }
              },
              agentRemove: function onRemove() {
                // We need this function for cases like HTTP 'upgrade'
                // (defined by WebSockets) where we need to remove a socket from the
                // pool because it'll be locked up indefinitely
                debug('CLIENT socket onRemove');
                agent.totalSocketCount--;
                agent.removeSocket(s, options);
                s.removeListener('close', onClose);
                s.removeListener('free', onFree);
                s.removeListener('timeout', onTimeout);
                s.removeListener('agentRemove', onRemove);
              },
              error: function socketErrorListener(err) {
                const socket = this;
                const req = socket._httpMessage;
                debug('SOCKET ERROR:', err.message, err.stack);

                if (req) {
                  // For Safety. Some additional errors might fire later on
                  // and we need to make sure we don't double-fire the error event.
                  req.socket._hadError = true;
                  req.emit('error', err);
                }

                const parser = socket.parser;
                if (parser) {
                  parser.finish();
                  freeParser(parser, req, socket);
                }

                // Ensure that no further data will come out of the socket
                socket.removeListener('data', socketOnData);
                socket.removeListener('end', socketOnEnd);
                socket.destroy();
              },
              finish: function () { [native code] },
            },
            _eventsCount: 10,
            connecting: false,
            _hadError: false,
            _parent: null,
            _host: "api.openai.com",
            _readableState: {
              objectMode: false,
              highWaterMark: 16384,
              buffer: {
                head: null,
                tail: null,
                length: 0,
              },
              length: 0,
              pipes: [
              ],
              flowing: true,
              ended: false,
              endEmitted: false,
              reading: true,
              constructed: true,
              sync: false,
              needReadable: true,
              emittedReadable: false,
              readableListening: false,
              resumeScheduled: false,
              errorEmitted: false,
              emitClose: false,
              autoDestroy: true,
              destroyed: false,
              errored: null,
              closed: false,
              closeEmitted: false,
              defaultEncoding: "utf8",
              awaitDrainWriters: null,
              multiAwaitDrain: false,
              readingMore: false,
              dataEmitted: true,
              decoder: null,
              encoding: null,
            },
            _maxListeners: undefined,
            _writableState: {
              objectMode: false,
              highWaterMark: 16384,
              finalCalled: true,
              needDrain: false,
              ending: true,
              ended: true,
              finished: false,
              destroyed: false,
              decodeStrings: false,
              defaultEncoding: "utf8",
              length: 0,
              writing: false,
              corked: 0,
              sync: false,
              bufferProcessing: false,
              onwrite: function () { [native code] },
              writecb: null,
              writelen: 0,
              afterWriteTickInfo: null,
              buffered: [
              ],
              bufferedIndex: 0,
              allBuffers: true,
              allNoop: true,
              pendingcb: 1,
              constructed: true,
              prefinished: false,
              errorEmitted: false,
              emitClose: false,
              autoDestroy: true,
              errored: null,
              closed: false,
              closeEmitted: false,
            },
            allowHalfOpen: false,
            _sockname: null,
            _pendingData: null,
            _pendingEncoding: "",
            server: undefined,
            _server: null,
            ssl: {
              _parent: {
                reading: true,
                onconnection: null,
              },
              _parentWrap: undefined,
              _secureContext: {
                context: {
                },
              },
              reading: true,
              onkeylog: function onkeylog(line) {
                debug('onkeylog');
                this[owner_symbol].emit('keylog', line);
              },
              onhandshakestart: function () { [native code] },
              onhandshakedone: () => {
                debug('client onhandshakedone');
                this._finishInit();
              },
              onocspresponse: function onocspresponse(resp) {
                debug('client onocspresponse');
                this[owner_symbol].emit('OCSPResponse', resp);
              },
              onnewsession: function onnewsessionclient(sessionId, session) {
                debug('client emit session');
                const owner = this[owner_symbol];
                if (owner[kIsVerified]) {
                  owner.emit('session', session);
                } else {
                  owner[kPendingSession] = session;
                }
              },
              onerror: function onerror(err) {
                const owner = this[owner_symbol];
                debug('%s onerror %s had? %j',
                      (typeof owner._tlsOptions === 'object' && owner._tlsOptions !== null) ?
                        owner._tlsOptions.isServer ? 'server' : 'client' :
                        'unknown',
                      err, owner._hadError);

                if (owner._hadError)
                  return;

                owner._hadError = true;

                // Destroy socket if error happened before handshake's finish
                if (!owner._secureEstablished) {
                  // When handshake fails control is not yet released,
                  // so self._tlsError will return null instead of actual error
                  owner.destroy(err);
                } else if (owner._tlsOptions?.isServer &&
                           owner._rejectUnauthorized &&
                           RegExpPrototypeTest(/peer did not return a certificate/,
                                               err.message)) {
                  // Ignore server's authorization errors
                  owner.destroy();
                } else {
                  // Emit error
                  owner._emitTLSError(err);
                }
              },
            },
            _requestCert: true,
            _rejectUnauthorized: true,
            parser: null,
            _httpMessage: [Circular],
          },
        ],
      },
      freeSockets: {
      },
      keepAliveMsecs: 1000,
      keepAlive: false,
      maxSockets: Infinity,
      maxFreeSockets: 256,
      scheduling: "lifo",
      maxTotalSockets: Infinity,
      totalSocketCount: 1,
      maxCachedSessions: 100,
      _sessionCache: {
        map: {
          "telemetry.nextjs.org:443:::::::::::::::::::::": new Uint8Array([48, 130, 6, 14, 2, 1, 1, 2, 2, 3, 4, 4, 2, 19, 3, 4, 32, 146, 171, 26, 251, 91, 147, 195, 158, 28, 230, 209, 204, 158, 161, 152, 17, 184, 241, 53, 128, 186, 51, 47, 153, 192, 195, 93, 64, 110, 173, 141, 136, 4, 32, 88, 235, 143, 68, 11, 161, 176, 56, 127, 243, 89, 112, 182, 169, 76, 249, 49, 89, 7, 7, 143, 140, 146, 133, 29, 75, 150, 181, 9, 67, 54, 56, 161, 6, 2, 4, 99, 153, 89, 221, 162, 4, 2, 2, 28, 32, 163, 130, 5, 45, 48, 130, 5, 41, 48, 130, 4, 17, 160, 3, 2, 1, 2, 2, 18, 3, 209, 185, 65, 158, 206, 41, 137, 53, 137, 199, 242, 127, 232, 177, 69, 136, 18, 48, 13, 6, 9, 42, 134, 72, 134, 247, 13, 1, 1, 11, 5, 0, 48, 50, 49, 11, 48, 9, 6, 3, 85, 4, 6, 19, 2, 85, 83, 49, 22, 48, 20, 6, 3, 85, 4, 10, 19, 13, 76, 101, 116, 39, 115, 32, 69, 110, 99, 114, 121, 112, 116, 49, 11, 48, 9, 6, 3, 85, 4, 3, 19, 2, 82, 51, 48, 30, 23, 13, 50, 50, 49, 48, 51, 49, 48, 52, 48, 57, 48, 54, 90, 23, 13, 50, 51, 48, 49, 50, 57, 48, 52, 48, 57, 48, 53, 90, 48, 23, 49, 21, 48, 19, 6, 3, 85, 4, 3, 12, 12, 42, 46, 110, 101, 120, 116, 106, 115, 46, 111, 114, 103, 48, 130, 1, 34, 48, 13, 6, 9, 42, 134, 72, 134, 247, 13, 1, 1, 1, 5, 0, 3, 130, 1, 15, 0, 48, 130, 1, 10, 2, 130, 1, 1, 0, 217, 177, 73, 245, 169, 218, 162, 53, 89, 140, 84, 63, 96, 139, 50, 209, 241, 221, 221, 218, 52, 161, 59, 4, 148, 37, 80, 73, 21, 47, 128, 48, 43, 177, 224, 220, 38, 162, 70, 48, 166, 126, 202, 53, 120, 213, 166, 232, 133, 125, 246, 212, 146, 221, 166, 40, 30, 37, 170, 97, 65, 6, 101, 132, 160, 224, 107, 159, 38, 36, 155, 218, 126, 82, 60, 122, 246, 38, 101, 225, 55, 118, 59, 216, 43, 134, 179, 10, 115, 35, 138, 217, 6, 53, 187, 39, 221, 82, 91, 185, 205, 58, 41, 59, 161, 247, 109, 62, 164, 245, 129, 203, 36, 34, 15, 193, 161, 20, 118, 5, 104, 223, 145, 239, 25, 204, 58, 212, 157, 6, 26, 163, 77, 114, 25, 126, 239, 229, 3, 234, 41, 24, 112, 176, 227, 65, 249, 31, 86, 63, 173, 185, 40, 172, 65, 183, 182, 144, 49, 104, 82, 142, 28, 77, 161, 65, 65, 69, 165, 146, 131, 73, 99, 207, 75, 105, 173, 129, 92, 239, 76, 145, 82, 177, 243, 114, 193, 216, 217, 145, 110, 76, 76, 240, 247, 235, 207, 235, 112, 147, 224, 112, 90, 199, 44, 72, 125, 240, 240, 252, 105, 155, 121, 63, 210, 97, 205, 94, 230, 134, 35, 88, 27, 210, 98, 202, 124, 236, 70, 96, 137, 102, 190, 21, 105, 192, 144, 102, 214, 118, 228, 152, 70, 7, 42, 116, 226, 217, 75, 166, 221, 248, 29, 160, 182, 239, 2, 3, 1, 0, 1, 163, 130, 2, 82, 48, 130, 2, 78, 48, 14, 6, 3, 85, 29, 15, 1, 1, 255, 4, 4, 3, 2, 5, 160, 48, 29, 6, 3, 85, 29, 37, 4, 22, 48, 20, 6, 8, 43, 6, 1, 5, 5, 7, 3, 1, 6, 8, 43, 6, 1, 5, 5, 7, 3, 2, 48, 12, 6, 3, 85, 29, 19, 1, 1, 255, 4, 2, 48, 0, 48, 29, 6, 3, 85, 29, 14, 4, 22, 4, 20, 125, 204, 92, 82, 33, 93, 193, 191, 63, 43, 60, 189, 55, 53, 134, 230, 7, 206, 159, 61, 48, 31, 6, 3, 85, 29, 35, 4, 24, 48, 22, 128, 20, 20, 46, 179, 23, 183, 88, 86, 203, 174, 80, 9, 64, 230, 31, 175, 157, 139, 20, 194, 198, 48, 85, 6, 8, 43, 6, 1, 5, 5, 7, 1, 1, 4, 73, 48, 71, 48, 33, 6, 8, 43, 6, 1, 5, 5, 7, 48, 1, 134, 21, 104, 116, 116, 112, 58, 47, 47, 114, 51, 46, 111, 46, 108, 101, 110, 99, 114, 46, 111, 114, 103, 48, 34, 6, 8, 43, 6, 1, 5, 5, 7, 48, 2, 134, 22, 104, 116, 116, 112, 58, 47, 47, 114, 51, 46, 105, 46, 108, 101, 110, 99, 114, 46, 111, 114, 103, 47, 48, 35, 6, 3, 85, 29, 17, 4, 28, 48, 26, 130, 12, 42, 46, 110, 101, 120, 116, 106, 115, 46, 111, 114, 103, 130, 10, 110, 101, 120, 116, 106, 115, 46, 111, 114, 103, 48, 76, 6, 3, 85, 29, 32, 4, 69, 48, 67, 48, 8, 6, 6, 103, 129, 12, 1, 2, 1, 48, 55, 6, 11, 43, 6, 1, 4, 1, 130, 223, 19, 1, 1, 1, 48, 40, 48, 38, 6, 8, 43, 6, 1, 5, 5, 7, 2, 1, 22, 26, 104, 116, 116, 112, 58, 47, 47, 99, 112, 115, 46, 108, 101, 116, 115, 101, 110, 99, 114, 121, 112, 116, 46, 111, 114, 103, 48, 130, 1, 3, 6, 10, 43, 6, 1, 4, 1, 214, 121, 2, 4, 2, 4, 129, 244, 4, 129, 241, 0, 239, 0, 118, 0, 232, 62, 208, 218, 62, 245, 6, 53, 50, 231, 87, 40, 188, 137, 107, 201, 3, 211, 203, 209, 17, 107, 236, 235, 105, 225, 119, 125, 109, 6, 189, 110, 0, 0, 1, 132, 44, 113, 126, 121, 0, 0, 4, 3, 0, 71, 48, 69, 2, 32, 29, 129, 36, 133, 240, 14, 129, 201, 58, 65, 195, 115, 74, 47, 104, 136, 83, 70, 190, 130, 241, 8, 193, 174, 191, 127, 67, 99, 60, 206, 160, 168, 2, 33, 0, 178, 70, 24, 237, 156, 211, 74, 57, 214, 172, 183, 187, 65, 246, 254, 167, 110, 253, 238, 65, 175, 4, 6, 130, 163, 183, 30, 21, 38, 19, 190, 214, 0, 117, 0, 183, 62, 251, 36, 223, 156, 77, 186, 117, 242, 57, 197, 186, 88, 244, 108, 93, 252, 66, 207, 122, 159, 53, 196, 158, 29, 9, 129, 37, 237, 180, 153, 0, 0, 1, 132, 44, 113, 128, 112, 0, 0, 4, 3, 0, 70, 48, 68, 2, 32, 61, 209, 195, 191, 194, 244, 2, 6, 76, 220, 92, 128, 148, 96, 127, 136, 161, 109, 189, 232, 106, 61, 187, 55, 19, 230, 151, 111, 151, 85, 97, 230, 2, 32, 87, 203, 69, 40, 97, 161, 146, 57, 181, 27, 125, 134, 239, 194, 206, 72, 17, 35, 191, 77, 20, 122, 158, 208, 95, 194, 135, 41, 168, 179, 251, 49, 48, 13, 6, 9, 42, 134, 72, 134, 247, 13, 1, 1, 11, 5, 0, 3, 130, 1, 1, 0, 62, 249, 227, 103, 157, 53, 11, 133, 68, 179, 12, 178, 54, 33, 192, 75, 11, 192, 100, 157, 135, 4, 178, 135, 105, 11, 241, 161, 125, 34, 130, 236, 123, 204, 24, 243, 102, 121, 247, 232, 90, 110, 86, 193, 82, 222, 22, 8, 21, 62, 53, 5, 230, 93, 231, 42, 2, 37, 233, 109, 157, 141, 202, 123, 239, 99, 226, 169, 148, 240, 49, 23, 104, 81, 171, 190, 217, 23, 233, 147, 206, 225, 37, 54, 37, 170, 172, 23, 171, 17, 58, 99, 9, 58, 29, 164, 196, 187, 19, 126, 37, 175, 41, 163, 57, 211, 180, 230, 241, 6, 93, 14, 140, 133, 219, 4, 75, 193, 254, 224, 28, 159, 23, 248, 96, 168, 93, 203, 1, 21, 63, 60, 108, 9, 68, 2, 115, 35, 142, 53, 26, 229, 58, 209, 208, 169, 122, 85, 184, 46, 6, 26, 247, 234, 240, 143, 35, 5, 232, 7, 231, 11, 60, 82, 218, 217, 146, 106, 8, 224, 178, 73, 82, 80, 6, 148, 81, 17, 29, 19, 111, 187, 27, 19, 139, 184, 198, 194, 44, 168, 136, 63, 98, 65, 254, 189, 116, 71, 62, 3, 91, 30, 9, 138, 119, 141, 203, 102, 180, 122, 23, 252, 153, 214, 111, 22, 85, 248, 232, 245, 110, 65, 236, 105, 23, 125, 236, 245, 95, 130, 234, 91, 236, 126, 64, 124, 205, 229, 255, 235, 12, 139, 24, 195, 189, 144, 192, 198, 49, 245, 177, 107, 74, 131, 71, 180, 164, 2, 4, 0, 169, 5, 2, 3, 9, 58, 128, 170, 115, 4, 113, 241, 99, 145, 139, 175, 197, 88, 234, 43, 43, 73, 88, 120, 50, 187, 62, 96, 235, 147, 165, 29, 143, 65, 135, 62, 136, 251, 150, 23, 151, 34, 54, 91, 13, 100, 15, 222, 47, 150, 181, 128, 15, 33, 130, 221, 198, 133, 207, 72, 175, 241, 57, 122, 208, 221, 0, 90, 235, 70, 83, 213, 44, 102, 67, 248, 123, 177, 87, 121, 64, 188, 243, 126, 130, 219, 14, 132, 91, 77, 221, 81, 209, 144, 236, 158, 96, 181, 101, 169, 247, 105, 64, 108, 136, 29, 93, 218, 127, 47, 207, 168, 253, 183, 43, 196, 131, 17, 126, 248, 131, 110, 238, 193]),
          "api.openai.com:443:::::::::::::::::::::": new Uint8Array([48, 130, 5, 224, 2, 1, 1, 2, 2, 3, 4, 4, 2, 19, 2, 4, 32, 185, 168, 255, 48, 126, 157, 25, 80, 202, 216, 64, 63, 72, 28, 151, 31, 158, 158, 126, 153, 138, 15, 189, 74, 158, 121, 135, 245, 223, 211, 208, 168, 4, 48, 121, 234, 168, 81, 196, 177, 38, 2, 8, 13, 74, 149, 208, 180, 89, 214, 190, 42, 46, 210, 53, 113, 248, 64, 41, 110, 19, 102, 96, 202, 128, 186, 89, 208, 37, 7, 191, 232, 191, 42, 96, 87, 9, 144, 189, 187, 36, 254, 161, 6, 2, 4, 99, 153, 89, 227, 162, 4, 2, 2, 28, 32, 163, 130, 5, 38, 48, 130, 5, 34, 48, 130, 4, 10, 160, 3, 2, 1, 2, 2, 18, 3, 241, 244, 209, 194, 243, 5, 26, 159, 244, 214, 95, 52, 255, 186, 80, 183, 66, 48, 13, 6, 9, 42, 134, 72, 134, 247, 13, 1, 1, 11, 5, 0, 48, 50, 49, 11, 48, 9, 6, 3, 85, 4, 6, 19, 2, 85, 83, 49, 22, 48, 20, 6, 3, 85, 4, 10, 19, 13, 76, 101, 116, 39, 115, 32, 69, 110, 99, 114, 121, 112, 116, 49, 11, 48, 9, 6, 3, 85, 4, 3, 19, 2, 82, 51, 48, 30, 23, 13, 50, 50, 49, 49, 49, 49, 49, 54, 48, 56, 49, 53, 90, 23, 13, 50, 51, 48, 50, 48, 57, 49, 54, 48, 56, 49, 52, 90, 48, 25, 49, 23, 48, 21, 6, 3, 85, 4, 3, 19, 14, 97, 112, 105, 46, 111, 112, 101, 110, 97, 105, 46, 99, 111, 109, 48, 130, 1, 34, 48, 13, 6, 9, 42, 134, 72, 134, 247, 13, 1, 1, 1, 5, 0, 3, 130, 1, 15, 0, 48, 130, 1, 10, 2, 130, 1, 1, 0, 173, 186, 208, 99, 33, 224, 132, 51, 181, 213, 33, 64, 230, 157, 255, 195, 73, 201, 105, 104, 24, 3, 148, 48, 170, 103, 151, 67, 177, 138, 40, 125, 111, 70, 30, 72, 222, 56, 111, 245, 117, 96, 76, 100, 126, 3, 209, 246, 129, 218, 228, 241, 53, 152, 194, 233, 24, 146, 16, 214, 220, 209, 127, 182, 129, 66, 221, 28, 101, 156, 182, 35, 198, 33, 209, 70, 141, 47, 136, 180, 181, 153, 165, 145, 99, 134, 148, 53, 240, 184, 211, 61, 175, 65, 171, 248, 97, 33, 101, 11, 214, 134, 125, 7, 35, 180, 52, 189, 115, 209, 209, 155, 35, 67, 76, 96, 80, 64, 57, 214, 2, 7, 150, 54, 154, 49, 4, 128, 85, 151, 48, 250, 126, 108, 120, 249, 52, 185, 50, 136, 93, 166, 206, 184, 7, 57, 215, 151, 204, 219, 27, 17, 133, 33, 126, 211, 129, 194, 57, 241, 241, 219, 213, 58, 49, 9, 230, 0, 162, 152, 48, 110, 142, 229, 150, 240, 100, 9, 3, 190, 164, 140, 207, 227, 155, 229, 28, 81, 136, 113, 178, 225, 89, 139, 222, 111, 106, 104, 175, 252, 138, 1, 141, 112, 236, 163, 180, 59, 30, 39, 194, 6, 45, 210, 75, 52, 70, 243, 52, 71, 12, 99, 81, 26, 96, 3, 176, 231, 122, 141, 205, 67, 197, 49, 131, 73, 186, 100, 56, 69, 92, 183, 66, 147, 208, 116, 78, 78, 242, 55, 28, 79, 22, 247, 151, 185, 2, 3, 1, 0, 1, 163, 130, 2, 73, 48, 130, 2, 69, 48, 14, 6, 3, 85, 29, 15, 1, 1, 255, 4, 4, 3, 2, 5, 160, 48, 29, 6, 3, 85, 29, 37, 4, 22, 48, 20, 6, 8, 43, 6, 1, 5, 5, 7, 3, 1, 6, 8, 43, 6, 1, 5, 5, 7, 3, 2, 48, 12, 6, 3, 85, 29, 19, 1, 1, 255, 4, 2, 48, 0, 48, 29, 6, 3, 85, 29, 14, 4, 22, 4, 20, 210, 230, 120, 43, 4, 83, 226, 7, 54, 91, 204, 226, 230, 206, 151, 149, 201, 222, 16, 94, 48, 31, 6, 3, 85, 29, 35, 4, 24, 48, 22, 128, 20, 20, 46, 179, 23, 183, 88, 86, 203, 174, 80, 9, 64, 230, 31, 175, 157, 139, 20, 194, 198, 48, 85, 6, 8, 43, 6, 1, 5, 5, 7, 1, 1, 4, 73, 48, 71, 48, 33, 6, 8, 43, 6, 1, 5, 5, 7, 48, 1, 134, 21, 104, 116, 116, 112, 58, 47, 47, 114, 51, 46, 111, 46, 108, 101, 110, 99, 114, 46, 111, 114, 103, 48, 34, 6, 8, 43, 6, 1, 5, 5, 7, 48, 2, 134, 22, 104, 116, 116, 112, 58, 47, 47, 114, 51, 46, 105, 46, 108, 101, 110, 99, 114, 46, 111, 114, 103, 47, 48, 25, 6, 3, 85, 29, 17, 4, 18, 48, 16, 130, 14, 97, 112, 105, 46, 111, 112, 101, 110, 97, 105, 46, 99, 111, 109, 48, 76, 6, 3, 85, 29, 32, 4, 69, 48, 67, 48, 8, 6, 6, 103, 129, 12, 1, 2, 1, 48, 55, 6, 11, 43, 6, 1, 4, 1, 130, 223, 19, 1, 1, 1, 48, 40, 48, 38, 6, 8, 43, 6, 1, 5, 5, 7, 2, 1, 22, 26, 104, 116, 116, 112, 58, 47, 47, 99, 112, 115, 46, 108, 101, 116, 115, 101, 110, 99, 114, 121, 112, 116, 46, 111, 114, 103, 48, 130, 1, 4, 6, 10, 43, 6, 1, 4, 1, 214, 121, 2, 4, 2, 4, 129, 245, 4, 129, 242, 0, 240, 0, 118, 0, 232, 62, 208, 218, 62, 245, 6, 53, 50, 231, 87, 40, 188, 137, 107, 201, 3, 211, 203, 209, 17, 107, 236, 235, 105, 225, 119, 125, 109, 6, 189, 110, 0, 0, 1, 132, 103, 169, 219, 227, 0, 0, 4, 3, 0, 71, 48, 69, 2, 33, 0, 193, 35, 255, 47, 184, 101, 64, 234, 184, 236, 141, 101, 202, 113, 75, 219, 101, 125, 70, 181, 190, 184, 240, 1, 169, 67, 61, 115, 122, 83, 72, 171, 2, 32, 85, 186, 90, 222, 104, 65, 203, 133, 46, 153, 99, 34, 98, 30, 73, 23, 13, 255, 21, 213, 126, 215, 57, 240, 28, 7, 252, 215, 50, 97, 80, 158, 0, 118, 0, 122, 50, 140, 84, 216, 183, 45, 182, 32, 234, 56, 224, 82, 30, 233, 132, 22, 112, 50, 19, 133, 77, 59, 210, 43, 193, 58, 87, 163, 82, 235, 82, 0, 0, 1, 132, 103, 169, 220, 135, 0, 0, 4, 3, 0, 71, 48, 69, 2, 33, 0, 218, 233, 199, 102, 211, 2, 56, 40, 154, 157, 167, 97, 200, 172, 234, 137, 190, 63, 55, 139, 92, 220, 96, 149, 252, 220, 233, 197, 140, 111, 61, 126, 2, 32, 7, 228, 84, 36, 105, 44, 12, 109, 72, 62, 226, 186, 136, 197, 73, 87, 170, 219, 53, 48, 194, 103, 12, 64, 91, 165, 9, 48, 193, 150, 85, 227, 48, 13, 6, 9, 42, 134, 72, 134, 247, 13, 1, 1, 11, 5, 0, 3, 130, 1, 1, 0, 103, 51, 247, 141, 115, 125, 32, 156, 160, 232, 167, 241, 224, 166, 27, 9, 229, 166, 207, 174, 34, 61, 121, 191, 27, 143, 166, 8, 143, 1, 211, 189, 120, 33, 82, 191, 157, 228, 158, 32, 184, 190, 65, 192, 81, 101, 195, 176, 21, 246, 53, 52, 85, 228, 134, 166, 52, 214, 165, 107, 8, 120, 82, 119, 117, 89, 94, 62, 95, 164, 20, 223, 253, 234, 206, 144, 192, 117, 144, 224, 56, 143, 27, 171, 237, 98, 199, 4, 204, 253, 185, 24, 210, 249, 177, 103, 79, 111, 44, 54, 156, 5, 4, 145, 240, 28, 152, 118, 68, 159, 85, 4, 106, 131, 20, 215, 143, 6, 178, 233, 146, 41, 42, 52, 149, 9, 15, 241, 1, 104, 186, 108, 125, 6, 61, 198, 161, 100, 22, 117, 162, 204, 239, 138, 46, 49, 169, 67, 208, 192, 128, 80, 47, 80, 0, 148, 150, 45, 238, 108, 6, 151, 83, 46, 162, 250, 89, 223, 51, 156, 53, 199, 186, 198, 244, 73, 246, 241, 128, 239, 111, 18, 52, 58, 90, 125, 247, 13, 216, 237, 19, 73, 215, 57, 85, 185, 211, 231, 62, 252, 121, 186, 128, 64, 178, 156, 48, 52, 4, 74, 116, 253, 88, 57, 66, 145, 80, 39, 138, 184, 162, 234, 172, 191, 190, 206, 233, 237, 204, 195, 234, 156, 239, 125, 233, 41, 90, 145, 146, 40, 123, 252, 229, 174, 117, 190, 86, 144, 84, 81, 111, 251, 149, 203, 74, 160, 164, 2, 4, 0, 166, 16, 4, 14, 97, 112, 105, 46, 111, 112, 101, 110, 97, 105, 46, 99, 111, 109, 169, 4, 2, 2, 2, 88, 170, 34, 4, 32, 242, 79, 248, 228, 155, 223, 15, 213, 137, 73, 53, 127, 164, 150, 70, 210, 211, 197, 232, 70, 188, 69, 145, 171, 126, 189, 128, 32, 186, 179, 27, 215, 174, 7, 2, 5, 0, 164, 163, 200, 90]),
        },
        list: [
          "telemetry.nextjs.org:443:::::::::::::::::::::",
          "api.openai.com:443:::::::::::::::::::::",
        ],
      },
    },
    socketPath: undefined,
    method: "POST",
    maxHeaderSize: undefined,
    insecureHTTPParser: undefined,
    path: "/v1/completions",
    _ended: true,
    res: {
      _readableState: {
        objectMode: false,
        highWaterMark: 16384,
        buffer: {
          head: null,
          tail: null,
          length: 0,
        },
        length: 0,
        pipes: [
        ],
        flowing: true,
        ended: true,
        endEmitted: true,
        reading: false,
        constructed: true,
        sync: true,
        needReadable: false,
        emittedReadable: false,
        readableListening: false,
        resumeScheduled: false,
        errorEmitted: false,
        emitClose: true,
        autoDestroy: true,
        destroyed: true,
        errored: null,
        closed: true,
        closeEmitted: true,
        defaultEncoding: "utf8",
        awaitDrainWriters: null,
        multiAwaitDrain: false,
        readingMore: true,
        dataEmitted: true,
        decoder: null,
        encoding: null,
      },
      _events: {
        end: [
          function responseOnEnd() {
            const req = this.req;
            const socket = req.socket;

            if (socket) {
              if (req.timeoutCb) socket.removeListener('timeout', emitRequestTimeout);
              socket.removeListener('timeout', responseOnTimeout);
            }

            req._ended = true;

            if (!req.shouldKeepAlive) {
              if (socket.writable) {
                debug('AGENT socket.destroySoon()');
                if (typeof socket.destroySoon === 'function')
                  socket.destroySoon();
                else
                  socket.end();
              }
              assert(!socket.writable);
            } else if (req.finished && !this.aborted) {
              // We can assume `req.finished` means all data has been written since:
              // - `'responseOnEnd'` means we have been assigned a socket.
              // - when we have a socket we write directly to it without buffering.
              // - `req.finished` means `end()` has been called and no further data.
              //   can be written
              responseKeepAlive(req);
            }
          },
          function handleStreamEnd() {
            try {
              var responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
              if (config.responseType !== 'arraybuffer') {
                responseData = responseData.toString(config.responseEncoding);
                if (!config.responseEncoding || config.responseEncoding === 'utf8') {
                  responseData = utils.stripBOM(responseData);
                }
              }
              response.data = responseData;
            } catch (err) {
              reject(enhanceError(err, config, err.code, response.request, response));
            }
            settle(resolve, reject, response);
          },
        ],
        data: function handleStreamData(chunk) {
          responseBuffer.push(chunk);
          totalResponseBytes += chunk.length;

          // make sure the content length is not over the maxContentLength if specified
          if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
            // stream.destoy() emit aborted event before calling reject() on Node.js v16
            rejected = true;
            stream.destroy();
            reject(createError('maxContentLength size of ' + config.maxContentLength + ' exceeded',
              config, null, lastRequest));
          }
        },
        aborted: function handlerStreamAborted() {
          if (rejected) {
            return;
          }
          stream.destroy();
          reject(createError('error request aborted', config, 'ERR_REQUEST_ABORTED', lastRequest));
        },
        error: function handleStreamError(err) {
          if (req.aborted) return;
          reject(enhanceError(err, config, null, lastRequest));
        },
      },
      _eventsCount: 4,
      _maxListeners: undefined,
      socket: {
        _tlsOptions: {
          allowHalfOpen: undefined,
          pipe: false,
          secureContext: {
            context: {
            },
          },
          isServer: false,
          requestCert: true,
          rejectUnauthorized: true,
          session: undefined,
          ALPNProtocols: undefined,
          requestOCSP: undefined,
          enableTrace: undefined,
          pskCallback: undefined,
          highWaterMark: undefined,
          onread: undefined,
          signal: undefined,
        },
        _secureEstablished: true,
        _securePending: false,
        _newSessionPending: false,
        _controlReleased: true,
        secureConnecting: false,
        _SNICallback: null,
        servername: "api.openai.com",
        alpnProtocol: false,
        authorized: true,
        authorizationError: null,
        encrypted: true,
        _events: {
          close: [
            function onSocketCloseDestroySSL() {
              // Make sure we are not doing it on OpenSSL's stack
              setImmediate(destroySSL, this);
              this[kRes] = null;
            },
            function () { [native code] },
            function onClose(err) {
              debug('CLIENT socket onClose');
              // This is the only place where sockets get removed from the Agent.
              // If you want to remove a socket from the pool, just close it.
              // All socket errors end in a close event anyway.
              agent.totalSocketCount--;
              agent.removeSocket(s, options);
            },
            function socketCloseListener() {
              const socket = this;
              const req = socket._httpMessage;
              debug('HTTP socket close');

              // NOTE: It's important to get parser here, because it could be freed by
              // the `socketOnData`.
              const parser = socket.parser;
              const res = req.res;

              req.destroyed = true;
              if (res) {
                // Socket closed before we emitted 'end' below.
                if (!res.complete) {
                  res.destroy(connResetException('aborted'));
                }
                req._closed = true;
                req.emit('close');
                if (!res.aborted && res.readable) {
                  res.push(null);
                }
              } else {
                if (!req.socket._hadError) {
                  // This socket error fired before we started to
                  // receive a response. The error needs to
                  // fire on the request.
                  req.socket._hadError = true;
                  req.emit('error', connResetException('socket hang up'));
                }
                req._closed = true;
                req.emit('close');
              }

              // Too bad.  That output wasn't getting written.
              // This is pretty terrible that it doesn't raise an error.
              // Fixed better in v0.10
              if (req.outputData)
                req.outputData.length = 0;

              if (parser) {
                parser.finish();
                freeParser(parser, req, socket);
              }
            },
          ],
          end: function onReadableStreamEnd() {
            if (!this.allowHalfOpen) {
              this.write = writeAfterFIN;
            }
          },
          newListener: function keylogNewListener(event) {
            if (event !== 'keylog')
              return;

            // Guard against enableKeylogCallback after destroy
            if (!this._handle) return;
            this._handle.enableKeylogCallback();

            // Remove this listener since it's no longer needed.
            this.removeListener('newListener', keylogNewListener);
          },
          secure: function onConnectSecure() {
            const options = this[kConnectOptions];

            // Check the size of DHE parameter above minimum requirement
            // specified in options.
            const ekeyinfo = this.getEphemeralKeyInfo();
            if (ekeyinfo.type === 'DH' && ekeyinfo.size < options.minDHSize) {
              const err = new ERR_TLS_DH_PARAM_SIZE(ekeyinfo.size);
              debug('client emit:', err);
              this.emit('error', err);
              this.destroy();
              return;
            }

            let verifyError = this._handle.verifyError();

            // Verify that server's identity matches it's certificate's names
            // Unless server has resumed our existing session
            if (!verifyError && !this.isSessionReused()) {
              const hostname = options.servername ||
                             options.host ||
                             (options.socket && options.socket._host) ||
                             'localhost';
              const cert = this.getPeerCertificate(true);
              verifyError = options.checkServerIdentity(hostname, cert);
            }

            if (verifyError) {
              this.authorized = false;
              this.authorizationError = verifyError.code || verifyError.message;

              // rejectUnauthorized property can be explicitly defined as `undefined`
              // causing the assignment to default value (`true`) fail. Before assigning
              // it to the tlssock connection options, explicitly check if it is false
              // and update rejectUnauthorized property. The property gets used by
              // TLSSocket connection handler to allow or reject connection if
              // unauthorized.
              // This check is potentially redundant, however it is better to keep it
              // in case the option object gets modified somewhere.
              if (options.rejectUnauthorized !== false) {
                this.destroy(verifyError);
                return;
              }
              debug('client emit secureConnect. rejectUnauthorized: %s, ' +
                    'authorizationError: %s', options.rejectUnauthorized,
                    this.authorizationError);
              this.secureConnecting = false;
              this.emit('secureConnect');
            } else {
              this.authorized = true;
              debug('client emit secureConnect. authorized:', this.authorized);
              this.secureConnecting = false;
              this.emit('secureConnect');
            }

            this[kIsVerified] = true;
            const session = this[kPendingSession];
            this[kPendingSession] = null;
            if (session)
              this.emit('session', session);

            this.removeListener('end', onConnectEnd);
          },
          session: (session) => {
            this._cacheSession(options._agentKey, session);
          },
          free: function onFree() {
            debug('CLIENT socket onFree');
            agent.emit('free', s, options);
          },
          timeout: function onTimeout() {
            debug('CLIENT socket onTimeout');

            // Destroy if in free list.
            // TODO(ronag): Always destroy, even if not in free list.
            const sockets = agent.freeSockets;
            if (ArrayPrototypeSome(ObjectKeys(sockets), (name) =>
              ArrayPrototypeIncludes(sockets[name], s)
            )) {
              return s.destroy();
            }
          },
          agentRemove: function onRemove() {
            // We need this function for cases like HTTP 'upgrade'
            // (defined by WebSockets) where we need to remove a socket from the
            // pool because it'll be locked up indefinitely
            debug('CLIENT socket onRemove');
            agent.totalSocketCount--;
            agent.removeSocket(s, options);
            s.removeListener('close', onClose);
            s.removeListener('free', onFree);
            s.removeListener('timeout', onTimeout);
            s.removeListener('agentRemove', onRemove);
          },
          error: function socketErrorListener(err) {
            const socket = this;
            const req = socket._httpMessage;
            debug('SOCKET ERROR:', err.message, err.stack);

            if (req) {
              // For Safety. Some additional errors might fire later on
              // and we need to make sure we don't double-fire the error event.
              req.socket._hadError = true;
              req.emit('error', err);
            }

            const parser = socket.parser;
            if (parser) {
              parser.finish();
              freeParser(parser, req, socket);
            }

            // Ensure that no further data will come out of the socket
            socket.removeListener('data', socketOnData);
            socket.removeListener('end', socketOnEnd);
            socket.destroy();
          },
          finish: function () { [native code] },
        },
        _eventsCount: 10,
        connecting: false,
        _hadError: false,
        _parent: null,
        _host: "api.openai.com",
        _readableState: {
          objectMode: false,
          highWaterMark: 16384,
          buffer: {
            head: null,
            tail: null,
            length: 0,
          },
          length: 0,
          pipes: [
          ],
          flowing: true,
          ended: false,
          endEmitted: false,
          reading: true,
          constructed: true,
          sync: false,
          needReadable: true,
          emittedReadable: false,
          readableListening: false,
          resumeScheduled: false,
          errorEmitted: false,
          emitClose: false,
          autoDestroy: true,
          destroyed: false,
          errored: null,
          closed: false,
          closeEmitted: false,
          defaultEncoding: "utf8",
          awaitDrainWriters: null,
          multiAwaitDrain: false,
          readingMore: false,
          dataEmitted: true,
          decoder: null,
          encoding: null,
        },
        _maxListeners: undefined,
        _writableState: {
          objectMode: false,
          highWaterMark: 16384,
          finalCalled: true,
          needDrain: false,
          ending: true,
          ended: true,
          finished: false,
          destroyed: false,
          decodeStrings: false,
          defaultEncoding: "utf8",
          length: 0,
          writing: false,
          corked: 0,
          sync: false,
          bufferProcessing: false,
          onwrite: function () { [native code] },
          writecb: null,
          writelen: 0,
          afterWriteTickInfo: null,
          buffered: [
          ],
          bufferedIndex: 0,
          allBuffers: true,
          allNoop: true,
          pendingcb: 1,
          constructed: true,
          prefinished: false,
          errorEmitted: false,
          emitClose: false,
          autoDestroy: true,
          errored: null,
          closed: false,
          closeEmitted: false,
        },
        allowHalfOpen: false,
        _sockname: null,
        _pendingData: null,
        _pendingEncoding: "",
        server: undefined,
        _server: null,
        ssl: {
          _parent: {
            reading: true,
            onconnection: null,
          },
          _parentWrap: undefined,
          _secureContext: {
            context: {
            },
          },
          reading: true,
          onkeylog: function onkeylog(line) {
            debug('onkeylog');
            this[owner_symbol].emit('keylog', line);
          },
          onhandshakestart: function () { [native code] },
          onhandshakedone: () => {
            debug('client onhandshakedone');
            this._finishInit();
          },
          onocspresponse: function onocspresponse(resp) {
            debug('client onocspresponse');
            this[owner_symbol].emit('OCSPResponse', resp);
          },
          onnewsession: function onnewsessionclient(sessionId, session) {
            debug('client emit session');
            const owner = this[owner_symbol];
            if (owner[kIsVerified]) {
              owner.emit('session', session);
            } else {
              owner[kPendingSession] = session;
            }
          },
          onerror: function onerror(err) {
            const owner = this[owner_symbol];
            debug('%s onerror %s had? %j',
                  (typeof owner._tlsOptions === 'object' && owner._tlsOptions !== null) ?
                    owner._tlsOptions.isServer ? 'server' : 'client' :
                    'unknown',
                  err, owner._hadError);

            if (owner._hadError)
              return;

            owner._hadError = true;

            // Destroy socket if error happened before handshake's finish
            if (!owner._secureEstablished) {
              // When handshake fails control is not yet released,
              // so self._tlsError will return null instead of actual error
              owner.destroy(err);
            } else if (owner._tlsOptions?.isServer &&
                       owner._rejectUnauthorized &&
                       RegExpPrototypeTest(/peer did not return a certificate/,
                                           err.message)) {
              // Ignore server's authorization errors
              owner.destroy();
            } else {
              // Emit error
              owner._emitTLSError(err);
            }
          },
        },
        _requestCert: true,
        _rejectUnauthorized: true,
        parser: null,
        _httpMessage: [Circular],
      },
      httpVersionMajor: 1,
      httpVersionMinor: 1,
      httpVersion: "1.1",
      complete: true,
      rawHeaders: [
        "Date",
        "Wed, 14 Dec 2022 05:06:49 GMT",
        "Content-Type",
        "application/json",
        "Content-Length",
        "1534",
        "Connection",
        "close",
        "Access-Control-Allow-Origin",
        "*",
        "Cache-Control",
        "no-cache, must-revalidate",
        "Openai-Model",
        "text-davinci-003",
        "Openai-Organization",
        "user-1qbprpgzlifvfzl2glfbtst9",
        "Openai-Processing-Ms",
        "5807",
        "Openai-Version",
        "2020-10-01",
        "Strict-Transport-Security",
        "max-age=15724800; includeSubDomains",
        "X-Request-Id",
        "50e9d04aae04a3b099d8630fb222d2ca",
      ],
      rawTrailers: [
      ],
      aborted: false,
      upgrade: false,
      url: "",
      method: null,
      statusCode: 200,
      statusMessage: "OK",
      client: {
        _tlsOptions: {
          allowHalfOpen: undefined,
          pipe: false,
          secureContext: {
            context: {
            },
          },
          isServer: false,
          requestCert: true,
          rejectUnauthorized: true,
          session: undefined,
          ALPNProtocols: undefined,
          requestOCSP: undefined,
          enableTrace: undefined,
          pskCallback: undefined,
          highWaterMark: undefined,
          onread: undefined,
          signal: undefined,
        },
        _secureEstablished: true,
        _securePending: false,
        _newSessionPending: false,
        _controlReleased: true,
        secureConnecting: false,
        _SNICallback: null,
        servername: "api.openai.com",
        alpnProtocol: false,
        authorized: true,
        authorizationError: null,
        encrypted: true,
        _events: {
          close: [
            function onSocketCloseDestroySSL() {
              // Make sure we are not doing it on OpenSSL's stack
              setImmediate(destroySSL, this);
              this[kRes] = null;
            },
            function () { [native code] },
            function onClose(err) {
              debug('CLIENT socket onClose');
              // This is the only place where sockets get removed from the Agent.
              // If you want to remove a socket from the pool, just close it.
              // All socket errors end in a close event anyway.
              agent.totalSocketCount--;
              agent.removeSocket(s, options);
            },
            function socketCloseListener() {
              const socket = this;
              const req = socket._httpMessage;
              debug('HTTP socket close');

              // NOTE: It's important to get parser here, because it could be freed by
              // the `socketOnData`.
              const parser = socket.parser;
              const res = req.res;

              req.destroyed = true;
              if (res) {
                // Socket closed before we emitted 'end' below.
                if (!res.complete) {
                  res.destroy(connResetException('aborted'));
                }
                req._closed = true;
                req.emit('close');
                if (!res.aborted && res.readable) {
                  res.push(null);
                }
              } else {
                if (!req.socket._hadError) {
                  // This socket error fired before we started to
                  // receive a response. The error needs to
                  // fire on the request.
                  req.socket._hadError = true;
                  req.emit('error', connResetException('socket hang up'));
                }
                req._closed = true;
                req.emit('close');
              }

              // Too bad.  That output wasn't getting written.
              // This is pretty terrible that it doesn't raise an error.
              // Fixed better in v0.10
              if (req.outputData)
                req.outputData.length = 0;

              if (parser) {
                parser.finish();
                freeParser(parser, req, socket);
              }
            },
          ],
          end: function onReadableStreamEnd() {
            if (!this.allowHalfOpen) {
              this.write = writeAfterFIN;
            }
          },
          newListener: function keylogNewListener(event) {
            if (event !== 'keylog')
              return;

            // Guard against enableKeylogCallback after destroy
            if (!this._handle) return;
            this._handle.enableKeylogCallback();

            // Remove this listener since it's no longer needed.
            this.removeListener('newListener', keylogNewListener);
          },
          secure: function onConnectSecure() {
            const options = this[kConnectOptions];

            // Check the size of DHE parameter above minimum requirement
            // specified in options.
            const ekeyinfo = this.getEphemeralKeyInfo();
            if (ekeyinfo.type === 'DH' && ekeyinfo.size < options.minDHSize) {
              const err = new ERR_TLS_DH_PARAM_SIZE(ekeyinfo.size);
              debug('client emit:', err);
              this.emit('error', err);
              this.destroy();
              return;
            }

            let verifyError = this._handle.verifyError();

            // Verify that server's identity matches it's certificate's names
            // Unless server has resumed our existing session
            if (!verifyError && !this.isSessionReused()) {
              const hostname = options.servername ||
                             options.host ||
                             (options.socket && options.socket._host) ||
                             'localhost';
              const cert = this.getPeerCertificate(true);
              verifyError = options.checkServerIdentity(hostname, cert);
            }

            if (verifyError) {
              this.authorized = false;
              this.authorizationError = verifyError.code || verifyError.message;

              // rejectUnauthorized property can be explicitly defined as `undefined`
              // causing the assignment to default value (`true`) fail. Before assigning
              // it to the tlssock connection options, explicitly check if it is false
              // and update rejectUnauthorized property. The property gets used by
              // TLSSocket connection handler to allow or reject connection if
              // unauthorized.
              // This check is potentially redundant, however it is better to keep it
              // in case the option object gets modified somewhere.
              if (options.rejectUnauthorized !== false) {
                this.destroy(verifyError);
                return;
              }
              debug('client emit secureConnect. rejectUnauthorized: %s, ' +
                    'authorizationError: %s', options.rejectUnauthorized,
                    this.authorizationError);
              this.secureConnecting = false;
              this.emit('secureConnect');
            } else {
              this.authorized = true;
              debug('client emit secureConnect. authorized:', this.authorized);
              this.secureConnecting = false;
              this.emit('secureConnect');
            }

            this[kIsVerified] = true;
            const session = this[kPendingSession];
            this[kPendingSession] = null;
            if (session)
              this.emit('session', session);

            this.removeListener('end', onConnectEnd);
          },
          session: (session) => {
            this._cacheSession(options._agentKey, session);
          },
          free: function onFree() {
            debug('CLIENT socket onFree');
            agent.emit('free', s, options);
          },
          timeout: function onTimeout() {
            debug('CLIENT socket onTimeout');

            // Destroy if in free list.
            // TODO(ronag): Always destroy, even if not in free list.
            const sockets = agent.freeSockets;
            if (ArrayPrototypeSome(ObjectKeys(sockets), (name) =>
              ArrayPrototypeIncludes(sockets[name], s)
            )) {
              return s.destroy();
            }
          },
          agentRemove: function onRemove() {
            // We need this function for cases like HTTP 'upgrade'
            // (defined by WebSockets) where we need to remove a socket from the
            // pool because it'll be locked up indefinitely
            debug('CLIENT socket onRemove');
            agent.totalSocketCount--;
            agent.removeSocket(s, options);
            s.removeListener('close', onClose);
            s.removeListener('free', onFree);
            s.removeListener('timeout', onTimeout);
            s.removeListener('agentRemove', onRemove);
          },
          error: function socketErrorListener(err) {
            const socket = this;
            const req = socket._httpMessage;
            debug('SOCKET ERROR:', err.message, err.stack);

            if (req) {
              // For Safety. Some additional errors might fire later on
              // and we need to make sure we don't double-fire the error event.
              req.socket._hadError = true;
              req.emit('error', err);
            }

            const parser = socket.parser;
            if (parser) {
              parser.finish();
              freeParser(parser, req, socket);
            }

            // Ensure that no further data will come out of the socket
            socket.removeListener('data', socketOnData);
            socket.removeListener('end', socketOnEnd);
            socket.destroy();
          },
          finish: function () { [native code] },
        },
        _eventsCount: 10,
        connecting: false,
        _hadError: false,
        _parent: null,
        _host: "api.openai.com",
        _readableState: {
          objectMode: false,
          highWaterMark: 16384,
          buffer: {
            head: null,
            tail: null,
            length: 0,
          },
          length: 0,
          pipes: [
          ],
          flowing: true,
          ended: false,
          endEmitted: false,
          reading: true,
          constructed: true,
          sync: false,
          needReadable: true,
          emittedReadable: false,
          readableListening: false,
          resumeScheduled: false,
          errorEmitted: false,
          emitClose: false,
          autoDestroy: true,
          destroyed: false,
          errored: null,
          closed: false,
          closeEmitted: false,
          defaultEncoding: "utf8",
          awaitDrainWriters: null,
          multiAwaitDrain: false,
          readingMore: false,
          dataEmitted: true,
          decoder: null,
          encoding: null,
        },
        _maxListeners: undefined,
        _writableState: {
          objectMode: false,
          highWaterMark: 16384,
          finalCalled: true,
          needDrain: false,
          ending: true,
          ended: true,
          finished: false,
          destroyed: false,
          decodeStrings: false,
          defaultEncoding: "utf8",
          length: 0,
          writing: false,
          corked: 0,
          sync: false,
          bufferProcessing: false,
          onwrite: function () { [native code] },
          writecb: null,
          writelen: 0,
          afterWriteTickInfo: null,
          buffered: [
          ],
          bufferedIndex: 0,
          allBuffers: true,
          allNoop: true,
          pendingcb: 1,
          constructed: true,
          prefinished: false,
          errorEmitted: false,
          emitClose: false,
          autoDestroy: true,
          errored: null,
          closed: false,
          closeEmitted: false,
        },
        allowHalfOpen: false,
        _sockname: null,
        _pendingData: null,
        _pendingEncoding: "",
        server: undefined,
        _server: null,
        ssl: {
          _parent: {
            reading: true,
            onconnection: null,
          },
          _parentWrap: undefined,
          _secureContext: {
            context: {
            },
          },
          reading: true,
          onkeylog: function onkeylog(line) {
            debug('onkeylog');
            this[owner_symbol].emit('keylog', line);
          },
          onhandshakestart: function () { [native code] },
          onhandshakedone: () => {
            debug('client onhandshakedone');
            this._finishInit();
          },
          onocspresponse: function onocspresponse(resp) {
            debug('client onocspresponse');
            this[owner_symbol].emit('OCSPResponse', resp);
          },
          onnewsession: function onnewsessionclient(sessionId, session) {
            debug('client emit session');
            const owner = this[owner_symbol];
            if (owner[kIsVerified]) {
              owner.emit('session', session);
            } else {
              owner[kPendingSession] = session;
            }
          },
          onerror: function onerror(err) {
            const owner = this[owner_symbol];
            debug('%s onerror %s had? %j',
                  (typeof owner._tlsOptions === 'object' && owner._tlsOptions !== null) ?
                    owner._tlsOptions.isServer ? 'server' : 'client' :
                    'unknown',
                  err, owner._hadError);

            if (owner._hadError)
              return;

            owner._hadError = true;

            // Destroy socket if error happened before handshake's finish
            if (!owner._secureEstablished) {
              // When handshake fails control is not yet released,
              // so self._tlsError will return null instead of actual error
              owner.destroy(err);
            } else if (owner._tlsOptions?.isServer &&
                       owner._rejectUnauthorized &&
                       RegExpPrototypeTest(/peer did not return a certificate/,
                                           err.message)) {
              // Ignore server's authorization errors
              owner.destroy();
            } else {
              // Emit error
              owner._emitTLSError(err);
            }
          },
        },
        _requestCert: true,
        _rejectUnauthorized: true,
        parser: null,
        _httpMessage: [Circular],
      },
      _consuming: false,
      _dumped: false,
      req: [Circular],
      responseUrl: "https://api.openai.com/v1/completions",
      redirects: [
      ],
    },
    aborted: false,
    timeoutCb: null,
    upgradeOrConnect: false,
    parser: null,
    maxHeadersCount: null,
    reusedSocket: false,
    host: "api.openai.com",
    protocol: "https:",
    _redirectable: {
      _writableState: {
        objectMode: false,
        highWaterMark: 16384,
        finalCalled: false,
        needDrain: false,
        ending: false,
        ended: false,
        finished: false,
        destroyed: false,
        decodeStrings: true,
        defaultEncoding: "utf8",
        length: 0,
        writing: false,
        corked: 0,
        sync: true,
        bufferProcessing: false,
        onwrite: function () { [native code] },
        writecb: null,
        writelen: 0,
        afterWriteTickInfo: null,
        buffered: [
        ],
        bufferedIndex: 0,
        allBuffers: true,
        allNoop: true,
        pendingcb: 0,
        constructed: true,
        prefinished: false,
        errorEmitted: false,
        emitClose: true,
        autoDestroy: true,
        errored: null,
        closed: false,
        closeEmitted: false,
      },
      _events: {
        response: function handleResponse(res) {
          if (req.aborted) return;

          // uncompress the response body transparently if required
          var stream = res;

          // return the last request in case of redirects
          var lastRequest = res.req || req;


          // if no content, is HEAD request or decompress disabled we should not decompress
          if (res.statusCode !== 204 && lastRequest.method !== 'HEAD' && config.decompress !== false) {
            switch (res.headers['content-encoding']) {
            /*eslint default-case:0*/
            case 'gzip':
            case 'compress':
            case 'deflate':
            // add the unzipper to the body stream processing pipeline
              stream = stream.pipe(zlib.createUnzip());

              // remove the content-encoding in order to not confuse downstream operations
              delete res.headers['content-encoding'];
              break;
            }
          }

          var response = {
            status: res.statusCode,
            statusText: res.statusMessage,
            headers: res.headers,
            config: config,
            request: lastRequest
          };

          if (config.responseType === 'stream') {
            response.data = stream;
            settle(resolve, reject, response);
          } else {
            var responseBuffer = [];
            var totalResponseBytes = 0;
            stream.on('data', function handleStreamData(chunk) {
              responseBuffer.push(chunk);
              totalResponseBytes += chunk.length;

              // make sure the content length is not over the maxContentLength if specified
              if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
                // stream.destoy() emit aborted event before calling reject() on Node.js v16
                rejected = true;
                stream.destroy();
                reject(createError('maxContentLength size of ' + config.maxContentLength + ' exceeded',
                  config, null, lastRequest));
              }
            });

            stream.on('aborted', function handlerStreamAborted() {
              if (rejected) {
                return;
              }
              stream.destroy();
              reject(createError('error request aborted', config, 'ERR_REQUEST_ABORTED', lastRequest));
            });

            stream.on('error', function handleStreamError(err) {
              if (req.aborted) return;
              reject(enhanceError(err, config, null, lastRequest));
            });

            stream.on('end', function handleStreamEnd() {
              try {
                var responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
                if (config.responseType !== 'arraybuffer') {
                  responseData = responseData.toString(config.responseEncoding);
                  if (!config.responseEncoding || config.responseEncoding === 'utf8') {
                    responseData = utils.stripBOM(responseData);
                  }
                }
                response.data = responseData;
              } catch (err) {
                reject(enhanceError(err, config, err.code, response.request, response));
              }
              settle(resolve, reject, response);
            });
          }
        },
        error: function handleRequestError(err) {
          if (req.aborted && err.code !== 'ERR_FR_TOO_MANY_REDIRECTS') return;
          reject(enhanceError(err, config, null, req));
        },
        socket: function handleRequestSocket(socket) {
          // default interval of sending ack packet is 1 minute
          socket.setKeepAlive(true, 1000 * 60);
        },
      },
      _eventsCount: 3,
      _maxListeners: undefined,
      _options: {
        maxRedirects: 21,
        maxBodyLength: 10485760,
        protocol: "https:",
        path: "/v1/completions",
        method: "POST",
        headers: {
          Accept: "application/json, text/plain, */*",
          "Content-Type": "application/json",
          "User-Agent": "OpenAI/NodeJS/3.1.0",
          Authorization: "Bearer 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",
          "Content-Length": 342,
        },
        agent: undefined,
        agents: {
          http: undefined,
          https: undefined,
        },
        auth: undefined,
        hostname: "api.openai.com",
        port: null,
        nativeProtocols: {
          "http:": {
            _connectionListener: function connectionListener(socket) {
              defaultTriggerAsyncIdScope(
                getOrSetAsyncId(socket), connectionListenerInternal, this, socket
              );
            },
            METHODS: [
              "ACL",
              "BIND",
              "CHECKOUT",
              "CONNECT",
              "COPY",
              "DELETE",
              "GET",
              "HEAD",
              "LINK",
              "LOCK",
              "M-SEARCH",
              "MERGE",
              "MKACTIVITY",
              "MKCALENDAR",
              "MKCOL",
              "MOVE",
              "NOTIFY",
              "OPTIONS",
              "PATCH",
              "POST",
              "PROPFIND",
              "PROPPATCH",
              "PURGE",
              "PUT",
              "REBIND",
              "REPORT",
              "SEARCH",
              "SOURCE",
              "SUBSCRIBE",
              "TRACE",
              "UNBIND",
              "UNLINK",
              "UNLOCK",
              "UNSUBSCRIBE",
            ],
            STATUS_CODES: {
              "100": "Continue",
              "101": "Switching Protocols",
              "102": "Processing",
              "103": "Early Hints",
              "200": "OK",
              "201": "Created",
              "202": "Accepted",
              "203": "Non-Authoritative Information",
              "204": "No Content",
              "205": "Reset Content",
              "206": "Partial Content",
              "207": "Multi-Status",
              "208": "Already Reported",
              "226": "IM Used",
              "300": "Multiple Choices",
              "301": "Moved Permanently",
              "302": "Found",
              "303": "See Other",
              "304": "Not Modified",
              "305": "Use Proxy",
              "307": "Temporary Redirect",
              "308": "Permanent Redirect",
              "400": "Bad Request",
              "401": "Unauthorized",
              "402": "Payment Required",
              "403": "Forbidden",
              "404": "Not Found",
              "405": "Method Not Allowed",
              "406": "Not Acceptable",
              "407": "Proxy Authentication Required",
              "408": "Request Timeout",
              "409": "Conflict",
              "410": "Gone",
              "411": "Length Required",
              "412": "Precondition Failed",
              "413": "Payload Too Large",
              "414": "URI Too Long",
              "415": "Unsupported Media Type",
              "416": "Range Not Satisfiable",
              "417": "Expectation Failed",
              "418": "I'm a Teapot",
              "421": "Misdirected Request",
              "422": "Unprocessable Entity",
              "423": "Locked",
              "424": "Failed Dependency",
              "425": "Too Early",
              "426": "Upgrade Required",
              "428": "Precondition Required",
              "429": "Too Many Requests",
              "431": "Request Header Fields Too Large",
              "451": "Unavailable For Legal Reasons",
              "500": "Internal Server Error",
              "501": "Not Implemented",
              "502": "Bad Gateway",
              "503": "Service Unavailable",
              "504": "Gateway Timeout",
              "505": "HTTP Version Not Supported",
              "506": "Variant Also Negotiates",
              "507": "Insufficient Storage",
              "508": "Loop Detected",
              "509": "Bandwidth Limit Exceeded",
              "510": "Not Extended",
              "511": "Network Authentication Required",
            },
            Agent: function Agent(options) {
              if (!(this instanceof Agent))
                return new Agent(options);

              FunctionPrototypeCall(EventEmitter, this);

              this.defaultPort = 80;
              this.protocol = 'http:';

              this.options = { __proto__: null, ...options };

              // Don't confuse net and make it think that we're connecting to a pipe
              this.options.path = null;
              this.requests = ObjectCreate(null);
              this.sockets = ObjectCreate(null);
              this.freeSockets = ObjectCreate(null);
              this.keepAliveMsecs = this.options.keepAliveMsecs || 1000;
              this.keepAlive = this.options.keepAlive || false;
              this.maxSockets = this.options.maxSockets || Agent.defaultMaxSockets;
              this.maxFreeSockets = this.options.maxFreeSockets || 256;
              this.scheduling = this.options.scheduling || 'lifo';
              this.maxTotalSockets = this.options.maxTotalSockets;
              this.totalSocketCount = 0;

              validateOneOf(this.scheduling, 'scheduling', ['fifo', 'lifo']);

              if (this.maxTotalSockets !== undefined) {
                validateNumber(this.maxTotalSockets, 'maxTotalSockets');
                if (this.maxTotalSockets <= 0 || NumberIsNaN(this.maxTotalSockets))
                  throw new ERR_OUT_OF_RANGE('maxTotalSockets', '> 0',
                                             this.maxTotalSockets);
              } else {
                this.maxTotalSockets = Infinity;
              }

              this.on('free', (socket, options) => {
                const name = this.getName(options);
                debug('agent.on(free)', name);

                // TODO(ronag): socket.destroy(err) might have been called
                // before coming here and have an 'error' scheduled. In the
                // case of socket.destroy() below this 'error' has no handler
                // and could cause unhandled exception.

                if (!socket.writable) {
                  socket.destroy();
                  return;
                }

                const requests = this.requests[name];
                if (requests && requests.length) {
                  const req = ArrayPrototypeShift(requests);
                  const reqAsyncRes = req[kRequestAsyncResource];
                  if (reqAsyncRes) {
                    // Run request within the original async context.
                    reqAsyncRes.runInAsyncScope(() => {
                      asyncResetHandle(socket);
                      setRequestSocket(this, req, socket);
                    });
                    req[kRequestAsyncResource] = null;
                  } else {
                    setRequestSocket(this, req, socket);
                  }
                  if (requests.length === 0) {
                    delete this.requests[name];
                  }
                  return;
                }

                // If there are no pending requests, then put it in
                // the freeSockets pool, but only if we're allowed to do so.
                const req = socket._httpMessage;
                if (!req || !req.shouldKeepAlive || !this.keepAlive) {
                  socket.destroy();
                  return;
                }

                const freeSockets = this.freeSockets[name] || [];
                const freeLen = freeSockets.length;
                let count = freeLen;
                if (this.sockets[name])
                  count += this.sockets[name].length;

                if (this.totalSocketCount > this.maxTotalSockets ||
                    count > this.maxSockets ||
                    freeLen >= this.maxFreeSockets ||
                    !this.keepSocketAlive(socket)) {
                  socket.destroy();
                  return;
                }

                this.freeSockets[name] = freeSockets;
                socket[async_id_symbol] = -1;
                socket._httpMessage = null;
                this.removeSocket(socket, options);

                socket.once('error', freeSocketErrorListener);
                ArrayPrototypePush(freeSockets, socket);
              });

              // Don't emit keylog events unless there is a listener for them.
              this.on('newListener', maybeEnableKeylog);
            },
            ClientRequest: function ClientRequest(input, options, cb) {
              FunctionPrototypeCall(OutgoingMessage, this);

              if (typeof input === 'string') {
                const urlStr = input;
                input = urlToHttpOptions(new URL(urlStr));
              } else if (input && input[searchParamsSymbol] &&
                         input[searchParamsSymbol][searchParamsSymbol]) {
                // url.URL instance
                input = urlToHttpOptions(input);
              } else {
                cb = options;
                options = input;
                input = null;
              }

              if (typeof options === 'function') {
                cb = options;
                options = input || {};
              } else {
                options = ObjectAssign(input || {}, options);
              }

              let agent = options.agent;
              const defaultAgent = options._defaultAgent || Agent.globalAgent;
              if (agent === false) {
                agent = new defaultAgent.constructor();
              } else if (agent === null || agent === undefined) {
                if (typeof options.createConnection !== 'function') {
                  agent = defaultAgent;
                }
                // Explicitly pass through this statement as agent will not be used
                // when createConnection is provided.
              } else if (typeof agent.addRequest !== 'function') {
                throw new ERR_INVALID_ARG_TYPE('options.agent',
                                               ['Agent-like Object', 'undefined', 'false'],
                                               agent);
              }
              this.agent = agent;

              const protocol = options.protocol || defaultAgent.protocol;
              let expectedProtocol = defaultAgent.protocol;
              if (this.agent && this.agent.protocol)
                expectedProtocol = this.agent.protocol;

              if (options.path) {
                const path = String(options.path);
                if (RegExpPrototypeTest(INVALID_PATH_REGEX, path))
                  throw new ERR_UNESCAPED_CHARACTERS('Request path');
              }

              if (protocol !== expectedProtocol) {
                throw new ERR_INVALID_PROTOCOL(protocol, expectedProtocol);
              }

              const defaultPort = options.defaultPort ||
                                (this.agent && this.agent.defaultPort);

              const port = options.port = options.port || defaultPort || 80;
              const host = options.host = validateHost(options.hostname, 'hostname') ||
                                        validateHost(options.host, 'host') || 'localhost';

              const setHost = (options.setHost === undefined || Boolean(options.setHost));

              this.socketPath = options.socketPath;

              if (options.timeout !== undefined)
                this.timeout = getTimerDuration(options.timeout, 'timeout');

              const signal = options.signal;
              if (signal) {
                addAbortSignal(signal, this);
              }
              let method = options.method;
              const methodIsString = (typeof method === 'string');
              if (method !== null && method !== undefined && !methodIsString) {
                throw new ERR_INVALID_ARG_TYPE('options.method', 'string', method);
              }

              if (methodIsString && method) {
                if (!checkIsHttpToken(method)) {
                  throw new ERR_INVALID_HTTP_TOKEN('Method', method);
                }
                method = this.method = StringPrototypeToUpperCase(method);
              } else {
                method = this.method = 'GET';
              }

              const maxHeaderSize = options.maxHeaderSize;
              if (maxHeaderSize !== undefined)
                validateInteger(maxHeaderSize, 'maxHeaderSize', 0);
              this.maxHeaderSize = maxHeaderSize;

              const insecureHTTPParser = options.insecureHTTPParser;
              if (insecureHTTPParser !== undefined &&
                  typeof insecureHTTPParser !== 'boolean') {
                throw new ERR_INVALID_ARG_TYPE(
                  'options.insecureHTTPParser', 'boolean', insecureHTTPParser);
              }
              this.insecureHTTPParser = insecureHTTPParser;

              this.path = options.path || '/';
              if (cb) {
                this.once('response', cb);
              }

              if (method === 'GET' ||
                  method === 'HEAD' ||
                  method === 'DELETE' ||
                  method === 'OPTIONS' ||
                  method === 'TRACE' ||
                  method === 'CONNECT') {
                this.useChunkedEncodingByDefault = false;
              } else {
                this.useChunkedEncodingByDefault = true;
              }

              this._ended = false;
              this.res = null;
              this.aborted = false;
              this.timeoutCb = null;
              this.upgradeOrConnect = false;
              this.parser = null;
              this.maxHeadersCount = null;
              this.reusedSocket = false;
              this.host = host;
              this.protocol = protocol;

              if (this.agent) {
                // If there is an agent we should default to Connection:keep-alive,
                // but only if the Agent will actually reuse the connection!
                // If it's not a keepAlive agent, and the maxSockets==Infinity, then
                // there's never a case where this socket will actually be reused
                if (!this.agent.keepAlive && !NumberIsFinite(this.agent.maxSockets)) {
                  this._last = true;
                  this.shouldKeepAlive = false;
                } else {
                  this._last = false;
                  this.shouldKeepAlive = true;
                }
              }

              const headersArray = ArrayIsArray(options.headers);
              if (!headersArray) {
                if (options.headers) {
                  const keys = ObjectKeys(options.headers);
                  // Retain for(;;) loop for performance reasons
                  // Refs: https://github.com/nodejs/node/pull/30958
                  for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    this.setHeader(key, options.headers[key]);
                  }
                }

                if (host && !this.getHeader('host') && setHost) {
                  let hostHeader = host;

                  // For the Host header, ensure that IPv6 addresses are enclosed
                  // in square brackets, as defined by URI formatting
                  // https://tools.ietf.org/html/rfc3986#section-3.2.2
                  const posColon = StringPrototypeIndexOf(hostHeader, ':');
                  if (posColon !== -1 &&
                      StringPrototypeIncludes(hostHeader, ':', posColon + 1) &&
                      StringPrototypeCharCodeAt(hostHeader, 0) !== 91/* '[' */) {
                    hostHeader = `[${hostHeader}]`;
                  }

                  if (port && +port !== defaultPort) {
                    hostHeader += ':' + port;
                  }
                  this.setHeader('Host', hostHeader);
                }

                if (options.auth && !this.getHeader('Authorization')) {
                  this.setHeader('Authorization', 'Basic ' +
                                 Buffer.from(options.auth).toString('base64'));
                }

                if (this.getHeader('expect')) {
                  if (this._header) {
                    throw new ERR_HTTP_HEADERS_SENT('render');
                  }

                  this._storeHeader(this.method + ' ' + this.path + ' HTTP/1.1\r\n',
                                    this[kOutHeaders]);
                }
              } else {
                this._storeHeader(this.method + ' ' + this.path + ' HTTP/1.1\r\n',
                                  options.headers);
              }

              let optsWithoutSignal = options;
              if (optsWithoutSignal.signal) {
                optsWithoutSignal = ObjectAssign({}, options);
                delete optsWithoutSignal.signal;
              }

              // initiate connection
              if (this.agent) {
                this.agent.addRequest(this, optsWithoutSignal);
              } else {
                // No agent, default to Connection:close.
                this._last = true;
                this.shouldKeepAlive = false;
                if (typeof optsWithoutSignal.createConnection === 'function') {
                  const oncreate = once((err, socket) => {
                    if (err) {
                      process.nextTick(() => this.emit('error', err));
                    } else {
                      this.onSocket(socket);
                    }
                  });

                  try {
                    const newSocket = optsWithoutSignal.createConnection(optsWithoutSignal,
                                                                         oncreate);
                    if (newSocket) {
                      oncreate(null, newSocket);
                    }
                  } catch (err) {
                    oncreate(err);
                  }
                } else {
                  debug('CLIENT use net.createConnection', optsWithoutSignal);
                  this.onSocket(net.createConnection(optsWithoutSignal));
                }
              }
            },
            IncomingMessage: function IncomingMessage(socket) {
              let streamOptions;

              if (socket) {
                streamOptions = {
                  highWaterMark: socket.readableHighWaterMark
                };
              }

              Readable.call(this, streamOptions);

              this._readableState.readingMore = true;

              this.socket = socket;

              this.httpVersionMajor = null;
              this.httpVersionMinor = null;
              this.httpVersion = null;
              this.complete = false;
              this[kHeaders] = null;
              this[kHeadersCount] = 0;
              this.rawHeaders = [];
              this[kTrailers] = null;
              this[kTrailersCount] = 0;
              this.rawTrailers = [];

              this.aborted = false;

              this.upgrade = null;

              // request (server) only
              this.url = '';
              this.method = null;

              // response (client) only
              this.statusCode = null;
              this.statusMessage = null;
              this.client = socket;

              this._consuming = false;
              // Flag for when we decide that this message cannot possibly be
              // read by the user, so there's no point continuing to handle it.
              this._dumped = false;
            },
            OutgoingMessage: function OutgoingMessage() {
              Stream.call(this);

              // Queue that holds all currently pending data, until the response will be
              // assigned to the socket (until it will its turn in the HTTP pipeline).
              this.outputData = [];

              // `outputSize` is an approximate measure of how much data is queued on this
              // response. `_onPendingData` will be invoked to update similar global
              // per-connection counter. That counter will be used to pause/unpause the
              // TCP socket and HTTP Parser and thus handle the backpressure.
              this.outputSize = 0;

              this.writable = true;
              this.destroyed = false;

              this._last = false;
              this.chunkedEncoding = false;
              this.shouldKeepAlive = true;
              this.maxRequestsOnConnectionReached = false;
              this._defaultKeepAlive = true;
              this.useChunkedEncodingByDefault = true;
              this.sendDate = false;
              this._removedConnection = false;
              this._removedContLen = false;
              this._removedTE = false;

              this._contentLength = null;
              this._hasBody = true;
              this._trailer = '';
              this[kNeedDrain] = false;

              this.finished = false;
              this._headerSent = false;
              this[kCorked] = 0;
              this._closed = false;

              this.socket = null;
              this._header = null;
              this[kOutHeaders] = null;

              this._keepAliveTimeout = 0;

              this._onPendingData = nop;
            },
            Server: function Server(options, requestListener) {
              if (!(this instanceof Server)) return new Server(options, requestListener);

              if (typeof options === 'function') {
                requestListener = options;
                options = {};
              } else if (options == null || typeof options === 'object') {
                options = { ...options };
              } else {
                throw new ERR_INVALID_ARG_TYPE('options', 'object', options);
              }

              storeHTTPOptions.call(this, options);
              net.Server.call(
                this,
                { allowHalfOpen: true, noDelay: options.noDelay,
                  keepAlive: options.keepAlive,
                  keepAliveInitialDelay: options.keepAliveInitialDelay });

              if (requestListener) {
                this.on('request', requestListener);
              }

              // Similar option to this. Too lazy to write my own docs.
              // http://www.squid-cache.org/Doc/config/half_closed_clients/
              // https://wiki.squid-cache.org/SquidFaq/InnerWorkings#What_is_a_half-closed_filedescriptor.3F
              this.httpAllowHalfOpen = false;

              this.on('connection', connectionListener);

              this.timeout = 0;
              this.keepAliveTimeout = 5000;
              this.maxHeadersCount = null;
              this.maxRequestsPerSocket = 0;
              this.headersTimeout = 60 * 1000; // 60 seconds
              this.requestTimeout = 0;
            },
            ServerResponse: function ServerResponse(req) {
              OutgoingMessage.call(this);

              if (req.method === 'HEAD') this._hasBody = false;

              this.req = req;
              this.sendDate = true;
              this._sent100 = false;
              this._expect_continue = false;

              if (req.httpVersionMajor < 1 || req.httpVersionMinor < 1) {
                this.useChunkedEncodingByDefault = RegExpPrototypeTest(chunkExpression,
                                                                       req.headers.te);
                this.shouldKeepAlive = false;
              }

              if (hasObserver('http')) {
                this[kServerResponseStatistics] = {
                  startTime: process.hrtime(),
                  type: 'HttpRequest',
                };
              }
            },
            createServer: function createServer(opts, requestListener) {
              return new Server(opts, requestListener);
            },
            validateHeaderName: (name) => {
              if (typeof name !== 'string' || !name || !checkIsHttpToken(name)) {
                throw new ERR_INVALID_HTTP_TOKEN('Header name', name);
              }
            },
            validateHeaderValue: (name, value) => {
              if (value === undefined) {
                throw new ERR_HTTP_INVALID_HEADER_VALUE(value, name);
              }
              if (checkInvalidHeaderChar(value)) {
                debug('Header "%s" contains invalid characters', name);
                throw new ERR_INVALID_CHAR('header content', name);
              }
            },
            get: function get(url, options, cb) {
              const req = request(url, options, cb);
              req.end();
              return req;
            },
            request: function request(url, options, cb) {
              return new ClientRequest(url, options, cb);
            },
            maxHeaderSize: 16384,
            globalAgent: {
              _events: {
                free: (socket, options) => {
                  const name = this.getName(options);
                  debug('agent.on(free)', name);

                  // TODO(ronag): socket.destroy(err) might have been called
                  // before coming here and have an 'error' scheduled. In the
                  // case of socket.destroy() below this 'error' has no handler
                  // and could cause unhandled exception.

                  if (!socket.writable) {
                    socket.destroy();
                    return;
                  }

                  const requests = this.requests[name];
                  if (requests && requests.length) {
                    const req = ArrayPrototypeShift(requests);
                    const reqAsyncRes = req[kRequestAsyncResource];
                    if (reqAsyncRes) {
                      // Run request within the original async context.
                      reqAsyncRes.runInAsyncScope(() => {
                        asyncResetHandle(socket);
                        setRequestSocket(this, req, socket);
                      });
                      req[kRequestAsyncResource] = null;
                    } else {
                      setRequestSocket(this, req, socket);
                    }
                    if (requests.length === 0) {
                      delete this.requests[name];
                    }
                    return;
                  }

                  // If there are no pending requests, then put it in
                  // the freeSockets pool, but only if we're allowed to do so.
                  const req = socket._httpMessage;
                  if (!req || !req.shouldKeepAlive || !this.keepAlive) {
                    socket.destroy();
                    return;
                  }

                  const freeSockets = this.freeSockets[name] || [];
                  const freeLen = freeSockets.length;
                  let count = freeLen;
                  if (this.sockets[name])
                    count += this.sockets[name].length;

                  if (this.totalSocketCount > this.maxTotalSockets ||
                      count > this.maxSockets ||
                      freeLen >= this.maxFreeSockets ||
                      !this.keepSocketAlive(socket)) {
                    socket.destroy();
                    return;
                  }

                  this.freeSockets[name] = freeSockets;
                  socket[async_id_symbol] = -1;
                  socket._httpMessage = null;
                  this.removeSocket(socket, options);

                  socket.once('error', freeSocketErrorListener);
                  ArrayPrototypePush(freeSockets, socket);
                },
                newListener: function maybeEnableKeylog(eventName) {
                  if (eventName === 'keylog') {
                    this.removeListener('newListener', maybeEnableKeylog);
                    // Future sockets will listen on keylog at creation.
                    const agent = this;
                    this[kOnKeylog] = function onkeylog(keylog) {
                      agent.emit('keylog', keylog, this);
                    };
                    // Existing sockets will start listening on keylog now.
                    const sockets = ObjectValues(this.sockets);
                    for (let i = 0; i < sockets.length; i++) {
                      sockets[i].on('keylog', this[kOnKeylog]);
                    }
                  }
                },
              },
              _eventsCount: 2,
              _maxListeners: undefined,
              defaultPort: 80,
              protocol: "http:",
              options: {
                path: null,
              },
              requests: {
              },
              sockets: {
              },
              freeSockets: {
              },
              keepAliveMsecs: 1000,
              keepAlive: false,
              maxSockets: Infinity,
              maxFreeSockets: 256,
              scheduling: "lifo",
              maxTotalSockets: Infinity,
              totalSocketCount: 0,
            },
          },
          "https:": {
            Agent: function Agent(options) {
              if (!(this instanceof Agent))
                return new Agent(options);

              FunctionPrototypeCall(HttpAgent, this, options);
              this.defaultPort = 443;
              this.protocol = 'https:';
              this.maxCachedSessions = this.options.maxCachedSessions;
              if (this.maxCachedSessions === undefined)
                this.maxCachedSessions = 100;

              this._sessionCache = {
                map: {},
                list: []
              };
            },
            globalAgent: {
              _events: {
                free: (socket, options) => {
                  const name = this.getName(options);
                  debug('agent.on(free)', name);

                  // TODO(ronag): socket.destroy(err) might have been called
                  // before coming here and have an 'error' scheduled. In the
                  // case of socket.destroy() below this 'error' has no handler
                  // and could cause unhandled exception.

                  if (!socket.writable) {
                    socket.destroy();
                    return;
                  }

                  const requests = this.requests[name];
                  if (requests && requests.length) {
                    const req = ArrayPrototypeShift(requests);
                    const reqAsyncRes = req[kRequestAsyncResource];
                    if (reqAsyncRes) {
                      // Run request within the original async context.
                      reqAsyncRes.runInAsyncScope(() => {
                        asyncResetHandle(socket);
                        setRequestSocket(this, req, socket);
                      });
                      req[kRequestAsyncResource] = null;
                    } else {
                      setRequestSocket(this, req, socket);
                    }
                    if (requests.length === 0) {
                      delete this.requests[name];
                    }
                    return;
                  }

                  // If there are no pending requests, then put it in
                  // the freeSockets pool, but only if we're allowed to do so.
                  const req = socket._httpMessage;
                  if (!req || !req.shouldKeepAlive || !this.keepAlive) {
                    socket.destroy();
                    return;
                  }

                  const freeSockets = this.freeSockets[name] || [];
                  const freeLen = freeSockets.length;
                  let count = freeLen;
                  if (this.sockets[name])
                    count += this.sockets[name].length;

                  if (this.totalSocketCount > this.maxTotalSockets ||
                      count > this.maxSockets ||
                      freeLen >= this.maxFreeSockets ||
                      !this.keepSocketAlive(socket)) {
                    socket.destroy();
                    return;
                  }

                  this.freeSockets[name] = freeSockets;
                  socket[async_id_symbol] = -1;
                  socket._httpMessage = null;
                  this.removeSocket(socket, options);

                  socket.once('error', freeSocketErrorListener);
                  ArrayPrototypePush(freeSockets, socket);
                },
                newListener: function maybeEnableKeylog(eventName) {
                  if (eventName === 'keylog') {
                    this.removeListener('newListener', maybeEnableKeylog);
                    // Future sockets will listen on keylog at creation.
                    const agent = this;
                    this[kOnKeylog] = function onkeylog(keylog) {
                      agent.emit('keylog', keylog, this);
                    };
                    // Existing sockets will start listening on keylog now.
                    const sockets = ObjectValues(this.sockets);
                    for (let i = 0; i < sockets.length; i++) {
                      sockets[i].on('keylog', this[kOnKeylog]);
                    }
                  }
                },
              },
              _eventsCount: 2,
              _maxListeners: undefined,
              defaultPort: 443,
              protocol: "https:",
              options: {
                path: null,
              },
              requests: {
              },
              sockets: {
                "api.openai.com:443:::::::::::::::::::::": [
                  {
                    _tlsOptions: {
                      allowHalfOpen: undefined,
                      pipe: false,
                      secureContext: {
                        context: {
                        },
                      },
                      isServer: false,
                      requestCert: true,
                      rejectUnauthorized: true,
                      session: undefined,
                      ALPNProtocols: undefined,
                      requestOCSP: undefined,
                      enableTrace: undefined,
                      pskCallback: undefined,
                      highWaterMark: undefined,
                      onread: undefined,
                      signal: undefined,
                    },
                    _secureEstablished: true,
                    _securePending: false,
                    _newSessionPending: false,
                    _controlReleased: true,
                    secureConnecting: false,
                    _SNICallback: null,
                    servername: "api.openai.com",
                    alpnProtocol: false,
                    authorized: true,
                    authorizationError: null,
                    encrypted: true,
                    _events: {
                      close: [
                        function onSocketCloseDestroySSL() {
                          // Make sure we are not doing it on OpenSSL's stack
                          setImmediate(destroySSL, this);
                          this[kRes] = null;
                        },
                        function () { [native code] },
                        function onClose(err) {
                          debug('CLIENT socket onClose');
                          // This is the only place where sockets get removed from the Agent.
                          // If you want to remove a socket from the pool, just close it.
                          // All socket errors end in a close event anyway.
                          agent.totalSocketCount--;
                          agent.removeSocket(s, options);
                        },
                        function socketCloseListener() {
                          const socket = this;
                          const req = socket._httpMessage;
                          debug('HTTP socket close');

                          // NOTE: It's important to get parser here, because it could be freed by
                          // the `socketOnData`.
                          const parser = socket.parser;
                          const res = req.res;

                          req.destroyed = true;
                          if (res) {
                            // Socket closed before we emitted 'end' below.
                            if (!res.complete) {
                              res.destroy(connResetException('aborted'));
                            }
                            req._closed = true;
                            req.emit('close');
                            if (!res.aborted && res.readable) {
                              res.push(null);
                            }
                          } else {
                            if (!req.socket._hadError) {
                              // This socket error fired before we started to
                              // receive a response. The error needs to
                              // fire on the request.
                              req.socket._hadError = true;
                              req.emit('error', connResetException('socket hang up'));
                            }
                            req._closed = true;
                            req.emit('close');
                          }

                          // Too bad.  That output wasn't getting written.
                          // This is pretty terrible that it doesn't raise an error.
                          // Fixed better in v0.10
                          if (req.outputData)
                            req.outputData.length = 0;

                          if (parser) {
                            parser.finish();
                            freeParser(parser, req, socket);
                          }
                        },
                      ],
                      end: function onReadableStreamEnd() {
                        if (!this.allowHalfOpen) {
                          this.write = writeAfterFIN;
                        }
                      },
                      newListener: function keylogNewListener(event) {
                        if (event !== 'keylog')
                          return;

                        // Guard against enableKeylogCallback after destroy
                        if (!this._handle) return;
                        this._handle.enableKeylogCallback();

                        // Remove this listener since it's no longer needed.
                        this.removeListener('newListener', keylogNewListener);
                      },
                      secure: function onConnectSecure() {
                        const options = this[kConnectOptions];

                        // Check the size of DHE parameter above minimum requirement
                        // specified in options.
                        const ekeyinfo = this.getEphemeralKeyInfo();
                        if (ekeyinfo.type === 'DH' && ekeyinfo.size < options.minDHSize) {
                          const err = new ERR_TLS_DH_PARAM_SIZE(ekeyinfo.size);
                          debug('client emit:', err);
                          this.emit('error', err);
                          this.destroy();
                          return;
                        }

                        let verifyError = this._handle.verifyError();

                        // Verify that server's identity matches it's certificate's names
                        // Unless server has resumed our existing session
                        if (!verifyError && !this.isSessionReused()) {
                          const hostname = options.servername ||
                                         options.host ||
                                         (options.socket && options.socket._host) ||
                                         'localhost';
                          const cert = this.getPeerCertificate(true);
                          verifyError = options.checkServerIdentity(hostname, cert);
                        }

                        if (verifyError) {
                          this.authorized = false;
                          this.authorizationError = verifyError.code || verifyError.message;

                          // rejectUnauthorized property can be explicitly defined as `undefined`
                          // causing the assignment to default value (`true`) fail. Before assigning
                          // it to the tlssock connection options, explicitly check if it is false
                          // and update rejectUnauthorized property. The property gets used by
                          // TLSSocket connection handler to allow or reject connection if
                          // unauthorized.
                          // This check is potentially redundant, however it is better to keep it
                          // in case the option object gets modified somewhere.
                          if (options.rejectUnauthorized !== false) {
                            this.destroy(verifyError);
                            return;
                          }
                          debug('client emit secureConnect. rejectUnauthorized: %s, ' +
                                'authorizationError: %s', options.rejectUnauthorized,
                                this.authorizationError);
                          this.secureConnecting = false;
                          this.emit('secureConnect');
                        } else {
                          this.authorized = true;
                          debug('client emit secureConnect. authorized:', this.authorized);
                          this.secureConnecting = false;
                          this.emit('secureConnect');
                        }

                        this[kIsVerified] = true;
                        const session = this[kPendingSession];
                        this[kPendingSession] = null;
                        if (session)
                          this.emit('session', session);

                        this.removeListener('end', onConnectEnd);
                      },
                      session: (session) => {
                        this._cacheSession(options._agentKey, session);
                      },
                      free: function onFree() {
                        debug('CLIENT socket onFree');
                        agent.emit('free', s, options);
                      },
                      timeout: function onTimeout() {
                        debug('CLIENT socket onTimeout');

                        // Destroy if in free list.
                        // TODO(ronag): Always destroy, even if not in free list.
                        const sockets = agent.freeSockets;
                        if (ArrayPrototypeSome(ObjectKeys(sockets), (name) =>
                          ArrayPrototypeIncludes(sockets[name], s)
                        )) {
                          return s.destroy();
                        }
                      },
                      agentRemove: function onRemove() {
                        // We need this function for cases like HTTP 'upgrade'
                        // (defined by WebSockets) where we need to remove a socket from the
                        // pool because it'll be locked up indefinitely
                        debug('CLIENT socket onRemove');
                        agent.totalSocketCount--;
                        agent.removeSocket(s, options);
                        s.removeListener('close', onClose);
                        s.removeListener('free', onFree);
                        s.removeListener('timeout', onTimeout);
                        s.removeListener('agentRemove', onRemove);
                      },
                      error: function socketErrorListener(err) {
                        const socket = this;
                        const req = socket._httpMessage;
                        debug('SOCKET ERROR:', err.message, err.stack);

                        if (req) {
                          // For Safety. Some additional errors might fire later on
                          // and we need to make sure we don't double-fire the error event.
                          req.socket._hadError = true;
                          req.emit('error', err);
                        }

                        const parser = socket.parser;
                        if (parser) {
                          parser.finish();
                          freeParser(parser, req, socket);
                        }

                        // Ensure that no further data will come out of the socket
                        socket.removeListener('data', socketOnData);
                        socket.removeListener('end', socketOnEnd);
                        socket.destroy();
                      },
                      finish: function () { [native code] },
                    },
                    _eventsCount: 10,
                    connecting: false,
                    _hadError: false,
                    _parent: null,
                    _host: "api.openai.com",
                    _readableState: {
                      objectMode: false,
                      highWaterMark: 16384,
                      buffer: {
                        head: null,
                        tail: null,
                        length: 0,
                      },
                      length: 0,
                      pipes: [
                      ],
                      flowing: true,
                      ended: false,
                      endEmitted: false,
                      reading: true,
                      constructed: true,
                      sync: false,
                      needReadable: true,
                      emittedReadable: false,
                      readableListening: false,
                      resumeScheduled: false,
                      errorEmitted: false,
                      emitClose: false,
                      autoDestroy: true,
                      destroyed: false,
                      errored: null,
                      closed: false,
                      closeEmitted: false,
                      defaultEncoding: "utf8",
                      awaitDrainWriters: null,
                      multiAwaitDrain: false,
                      readingMore: false,
                      dataEmitted: true,
                      decoder: null,
                      encoding: null,
                    },
                    _maxListeners: undefined,
                    _writableState: {
                      objectMode: false,
                      highWaterMark: 16384,
                      finalCalled: true,
                      needDrain: false,
                      ending: true,
                      ended: true,
                      finished: false,
                      destroyed: false,
                      decodeStrings: false,
                      defaultEncoding: "utf8",
                      length: 0,
                      writing: false,
                      corked: 0,
                      sync: false,
                      bufferProcessing: false,
                      onwrite: function () { [native code] },
                      writecb: null,
                      writelen: 0,
                      afterWriteTickInfo: null,
                      buffered: [
                      ],
                      bufferedIndex: 0,
                      allBuffers: true,
                      allNoop: true,
                      pendingcb: 1,
                      constructed: true,
                      prefinished: false,
                      errorEmitted: false,
                      emitClose: false,
                      autoDestroy: true,
                      errored: null,
                      closed: false,
                      closeEmitted: false,
                    },
                    allowHalfOpen: false,
                    _sockname: null,
                    _pendingData: null,
                    _pendingEncoding: "",
                    server: undefined,
                    _server: null,
                    ssl: {
                      _parent: {
                        reading: true,
                        onconnection: null,
                      },
                      _parentWrap: undefined,
                      _secureContext: {
                        context: {
                        },
                      },
                      reading: true,
                      onkeylog: function onkeylog(line) {
                        debug('onkeylog');
                        this[owner_symbol].emit('keylog', line);
                      },
                      onhandshakestart: function () { [native code] },
                      onhandshakedone: () => {
                        debug('client onhandshakedone');
                        this._finishInit();
                      },
                      onocspresponse: function onocspresponse(resp) {
                        debug('client onocspresponse');
                        this[owner_symbol].emit('OCSPResponse', resp);
                      },
                      onnewsession: function onnewsessionclient(sessionId, session) {
                        debug('client emit session');
                        const owner = this[owner_symbol];
                        if (owner[kIsVerified]) {
                          owner.emit('session', session);
                        } else {
                          owner[kPendingSession] = session;
                        }
                      },
                      onerror: function onerror(err) {
                        const owner = this[owner_symbol];
                        debug('%s onerror %s had? %j',
                              (typeof owner._tlsOptions === 'object' && owner._tlsOptions !== null) ?
                                owner._tlsOptions.isServer ? 'server' : 'client' :
                                'unknown',
                              err, owner._hadError);

                        if (owner._hadError)
                          return;

                        owner._hadError = true;

                        // Destroy socket if error happened before handshake's finish
                        if (!owner._secureEstablished) {
                          // When handshake fails control is not yet released,
                          // so self._tlsError will return null instead of actual error
                          owner.destroy(err);
                        } else if (owner._tlsOptions?.isServer &&
                                   owner._rejectUnauthorized &&
                                   RegExpPrototypeTest(/peer did not return a certificate/,
                                                       err.message)) {
                          // Ignore server's authorization errors
                          owner.destroy();
                        } else {
                          // Emit error
                          owner._emitTLSError(err);
                        }
                      },
                    },
                    _requestCert: true,
                    _rejectUnauthorized: true,
                    parser: null,
                    _httpMessage: [Circular],
                  },
                ],
              },
              freeSockets: {
              },
              keepAliveMsecs: 1000,
              keepAlive: false,
              maxSockets: Infinity,
              maxFreeSockets: 256,
              scheduling: "lifo",
              maxTotalSockets: Infinity,
              totalSocketCount: 1,
              maxCachedSessions: 100,
              _sessionCache: {
                map: {
                  "telemetry.nextjs.org:443:::::::::::::::::::::": new Uint8Array([48, 130, 6, 14, 2, 1, 1, 2, 2, 3, 4, 4, 2, 19, 3, 4, 32, 146, 171, 26, 251, 91, 147, 195, 158, 28, 230, 209, 204, 158, 161, 152, 17, 184, 241, 53, 128, 186, 51, 47, 153, 192, 195, 93, 64, 110, 173, 141, 136, 4, 32, 88, 235, 143, 68, 11, 161, 176, 56, 127, 243, 89, 112, 182, 169, 76, 249, 49, 89, 7, 7, 143, 140, 146, 133, 29, 75, 150, 181, 9, 67, 54, 56, 161, 6, 2, 4, 99, 153, 89, 221, 162, 4, 2, 2, 28, 32, 163, 130, 5, 45, 48, 130, 5, 41, 48, 130, 4, 17, 160, 3, 2, 1, 2, 2, 18, 3, 209, 185, 65, 158, 206, 41, 137, 53, 137, 199, 242, 127, 232, 177, 69, 136, 18, 48, 13, 6, 9, 42, 134, 72, 134, 247, 13, 1, 1, 11, 5, 0, 48, 50, 49, 11, 48, 9, 6, 3, 85, 4, 6, 19, 2, 85, 83, 49, 22, 48, 20, 6, 3, 85, 4, 10, 19, 13, 76, 101, 116, 39, 115, 32, 69, 110, 99, 114, 121, 112, 116, 49, 11, 48, 9, 6, 3, 85, 4, 3, 19, 2, 82, 51, 48, 30, 23, 13, 50, 50, 49, 48, 51, 49, 48, 52, 48, 57, 48, 54, 90, 23, 13, 50, 51, 48, 49, 50, 57, 48, 52, 48, 57, 48, 53, 90, 48, 23, 49, 21, 48, 19, 6, 3, 85, 4, 3, 12, 12, 42, 46, 110, 101, 120, 116, 106, 115, 46, 111, 114, 103, 48, 130, 1, 34, 48, 13, 6, 9, 42, 134, 72, 134, 247, 13, 1, 1, 1, 5, 0, 3, 130, 1, 15, 0, 48, 130, 1, 10, 2, 130, 1, 1, 0, 217, 177, 73, 245, 169, 218, 162, 53, 89, 140, 84, 63, 96, 139, 50, 209, 241, 221, 221, 218, 52, 161, 59, 4, 148, 37, 80, 73, 21, 47, 128, 48, 43, 177, 224, 220, 38, 162, 70, 48, 166, 126, 202, 53, 120, 213, 166, 232, 133, 125, 246, 212, 146, 221, 166, 40, 30, 37, 170, 97, 65, 6, 101, 132, 160, 224, 107, 159, 38, 36, 155, 218, 126, 82, 60, 122, 246, 38, 101, 225, 55, 118, 59, 216, 43, 134, 179, 10, 115, 35, 138, 217, 6, 53, 187, 39, 221, 82, 91, 185, 205, 58, 41, 59, 161, 247, 109, 62, 164, 245, 129, 203, 36, 34, 15, 193, 161, 20, 118, 5, 104, 223, 145, 239, 25, 204, 58, 212, 157, 6, 26, 163, 77, 114, 25, 126, 239, 229, 3, 234, 41, 24, 112, 176, 227, 65, 249, 31, 86, 63, 173, 185, 40, 172, 65, 183, 182, 144, 49, 104, 82, 142, 28, 77, 161, 65, 65, 69, 165, 146, 131, 73, 99, 207, 75, 105, 173, 129, 92, 239, 76, 145, 82, 177, 243, 114, 193, 216, 217, 145, 110, 76, 76, 240, 247, 235, 207, 235, 112, 147, 224, 112, 90, 199, 44, 72, 125, 240, 240, 252, 105, 155, 121, 63, 210, 97, 205, 94, 230, 134, 35, 88, 27, 210, 98, 202, 124, 236, 70, 96, 137, 102, 190, 21, 105, 192, 144, 102, 214, 118, 228, 152, 70, 7, 42, 116, 226, 217, 75, 166, 221, 248, 29, 160, 182, 239, 2, 3, 1, 0, 1, 163, 130, 2, 82, 48, 130, 2, 78, 48, 14, 6, 3, 85, 29, 15, 1, 1, 255, 4, 4, 3, 2, 5, 160, 48, 29, 6, 3, 85, 29, 37, 4, 22, 48, 20, 6, 8, 43, 6, 1, 5, 5, 7, 3, 1, 6, 8, 43, 6, 1, 5, 5, 7, 3, 2, 48, 12, 6, 3, 85, 29, 19, 1, 1, 255, 4, 2, 48, 0, 48, 29, 6, 3, 85, 29, 14, 4, 22, 4, 20, 125, 204, 92, 82, 33, 93, 193, 191, 63, 43, 60, 189, 55, 53, 134, 230, 7, 206, 159, 61, 48, 31, 6, 3, 85, 29, 35, 4, 24, 48, 22, 128, 20, 20, 46, 179, 23, 183, 88, 86, 203, 174, 80, 9, 64, 230, 31, 175, 157, 139, 20, 194, 198, 48, 85, 6, 8, 43, 6, 1, 5, 5, 7, 1, 1, 4, 73, 48, 71, 48, 33, 6, 8, 43, 6, 1, 5, 5, 7, 48, 1, 134, 21, 104, 116, 116, 112, 58, 47, 47, 114, 51, 46, 111, 46, 108, 101, 110, 99, 114, 46, 111, 114, 103, 48, 34, 6, 8, 43, 6, 1, 5, 5, 7, 48, 2, 134, 22, 104, 116, 116, 112, 58, 47, 47, 114, 51, 46, 105, 46, 108, 101, 110, 99, 114, 46, 111, 114, 103, 47, 48, 35, 6, 3, 85, 29, 17, 4, 28, 48, 26, 130, 12, 42, 46, 110, 101, 120, 116, 106, 115, 46, 111, 114, 103, 130, 10, 110, 101, 120, 116, 106, 115, 46, 111, 114, 103, 48, 76, 6, 3, 85, 29, 32, 4, 69, 48, 67, 48, 8, 6, 6, 103, 129, 12, 1, 2, 1, 48, 55, 6, 11, 43, 6, 1, 4, 1, 130, 223, 19, 1, 1, 1, 48, 40, 48, 38, 6, 8, 43, 6, 1, 5, 5, 7, 2, 1, 22, 26, 104, 116, 116, 112, 58, 47, 47, 99, 112, 115, 46, 108, 101, 116, 115, 101, 110, 99, 114, 121, 112, 116, 46, 111, 114, 103, 48, 130, 1, 3, 6, 10, 43, 6, 1, 4, 1, 214, 121, 2, 4, 2, 4, 129, 244, 4, 129, 241, 0, 239, 0, 118, 0, 232, 62, 208, 218, 62, 245, 6, 53, 50, 231, 87, 40, 188, 137, 107, 201, 3, 211, 203, 209, 17, 107, 236, 235, 105, 225, 119, 125, 109, 6, 189, 110, 0, 0, 1, 132, 44, 113, 126, 121, 0, 0, 4, 3, 0, 71, 48, 69, 2, 32, 29, 129, 36, 133, 240, 14, 129, 201, 58, 65, 195, 115, 74, 47, 104, 136, 83, 70, 190, 130, 241, 8, 193, 174, 191, 127, 67, 99, 60, 206, 160, 168, 2, 33, 0, 178, 70, 24, 237, 156, 211, 74, 57, 214, 172, 183, 187, 65, 246, 254, 167, 110, 253, 238, 65, 175, 4, 6, 130, 163, 183, 30, 21, 38, 19, 190, 214, 0, 117, 0, 183, 62, 251, 36, 223, 156, 77, 186, 117, 242, 57, 197, 186, 88, 244, 108, 93, 252, 66, 207, 122, 159, 53, 196, 158, 29, 9, 129, 37, 237, 180, 153, 0, 0, 1, 132, 44, 113, 128, 112, 0, 0, 4, 3, 0, 70, 48, 68, 2, 32, 61, 209, 195, 191, 194, 244, 2, 6, 76, 220, 92, 128, 148, 96, 127, 136, 161, 109, 189, 232, 106, 61, 187, 55, 19, 230, 151, 111, 151, 85, 97, 230, 2, 32, 87, 203, 69, 40, 97, 161, 146, 57, 181, 27, 125, 134, 239, 194, 206, 72, 17, 35, 191, 77, 20, 122, 158, 208, 95, 194, 135, 41, 168, 179, 251, 49, 48, 13, 6, 9, 42, 134, 72, 134, 247, 13, 1, 1, 11, 5, 0, 3, 130, 1, 1, 0, 62, 249, 227, 103, 157, 53, 11, 133, 68, 179, 12, 178, 54, 33, 192, 75, 11, 192, 100, 157, 135, 4, 178, 135, 105, 11, 241, 161, 125, 34, 130, 236, 123, 204, 24, 243, 102, 121, 247, 232, 90, 110, 86, 193, 82, 222, 22, 8, 21, 62, 53, 5, 230, 93, 231, 42, 2, 37, 233, 109, 157, 141, 202, 123, 239, 99, 226, 169, 148, 240, 49, 23, 104, 81, 171, 190, 217, 23, 233, 147, 206, 225, 37, 54, 37, 170, 172, 23, 171, 17, 58, 99, 9, 58, 29, 164, 196, 187, 19, 126, 37, 175, 41, 163, 57, 211, 180, 230, 241, 6, 93, 14, 140, 133, 219, 4, 75, 193, 254, 224, 28, 159, 23, 248, 96, 168, 93, 203, 1, 21, 63, 60, 108, 9, 68, 2, 115, 35, 142, 53, 26, 229, 58, 209, 208, 169, 122, 85, 184, 46, 6, 26, 247, 234, 240, 143, 35, 5, 232, 7, 231, 11, 60, 82, 218, 217, 146, 106, 8, 224, 178, 73, 82, 80, 6, 148, 81, 17, 29, 19, 111, 187, 27, 19, 139, 184, 198, 194, 44, 168, 136, 63, 98, 65, 254, 189, 116, 71, 62, 3, 91, 30, 9, 138, 119, 141, 203, 102, 180, 122, 23, 252, 153, 214, 111, 22, 85, 248, 232, 245, 110, 65, 236, 105, 23, 125, 236, 245, 95, 130, 234, 91, 236, 126, 64, 124, 205, 229, 255, 235, 12, 139, 24, 195, 189, 144, 192, 198, 49, 245, 177, 107, 74, 131, 71, 180, 164, 2, 4, 0, 169, 5, 2, 3, 9, 58, 128, 170, 115, 4, 113, 241, 99, 145, 139, 175, 197, 88, 234, 43, 43, 73, 88, 120, 50, 187, 62, 96, 235, 147, 165, 29, 143, 65, 135, 62, 136, 251, 150, 23, 151, 34, 54, 91, 13, 100, 15, 222, 47, 150, 181, 128, 15, 33, 130, 221, 198, 133, 207, 72, 175, 241, 57, 122, 208, 221, 0, 90, 235, 70, 83, 213, 44, 102, 67, 248, 123, 177, 87, 121, 64, 188, 243, 126, 130, 219, 14, 132, 91, 77, 221, 81, 209, 144, 236, 158, 96, 181, 101, 169, 247, 105, 64, 108, 136, 29, 93, 218, 127, 47, 207, 168, 253, 183, 43, 196, 131, 17, 126, 248, 131, 110, 238, 193]),
                  "api.openai.com:443:::::::::::::::::::::": new Uint8Array([48, 130, 5, 224, 2, 1, 1, 2, 2, 3, 4, 4, 2, 19, 2, 4, 32, 185, 168, 255, 48, 126, 157, 25, 80, 202, 216, 64, 63, 72, 28, 151, 31, 158, 158, 126, 153, 138, 15, 189, 74, 158, 121, 135, 245, 223, 211, 208, 168, 4, 48, 121, 234, 168, 81, 196, 177, 38, 2, 8, 13, 74, 149, 208, 180, 89, 214, 190, 42, 46, 210, 53, 113, 248, 64, 41, 110, 19, 102, 96, 202, 128, 186, 89, 208, 37, 7, 191, 232, 191, 42, 96, 87, 9, 144, 189, 187, 36, 254, 161, 6, 2, 4, 99, 153, 89, 227, 162, 4, 2, 2, 28, 32, 163, 130, 5, 38, 48, 130, 5, 34, 48, 130, 4, 10, 160, 3, 2, 1, 2, 2, 18, 3, 241, 244, 209, 194, 243, 5, 26, 159, 244, 214, 95, 52, 255, 186, 80, 183, 66, 48, 13, 6, 9, 42, 134, 72, 134, 247, 13, 1, 1, 11, 5, 0, 48, 50, 49, 11, 48, 9, 6, 3, 85, 4, 6, 19, 2, 85, 83, 49, 22, 48, 20, 6, 3, 85, 4, 10, 19, 13, 76, 101, 116, 39, 115, 32, 69, 110, 99, 114, 121, 112, 116, 49, 11, 48, 9, 6, 3, 85, 4, 3, 19, 2, 82, 51, 48, 30, 23, 13, 50, 50, 49, 49, 49, 49, 49, 54, 48, 56, 49, 53, 90, 23, 13, 50, 51, 48, 50, 48, 57, 49, 54, 48, 56, 49, 52, 90, 48, 25, 49, 23, 48, 21, 6, 3, 85, 4, 3, 19, 14, 97, 112, 105, 46, 111, 112, 101, 110, 97, 105, 46, 99, 111, 109, 48, 130, 1, 34, 48, 13, 6, 9, 42, 134, 72, 134, 247, 13, 1, 1, 1, 5, 0, 3, 130, 1, 15, 0, 48, 130, 1, 10, 2, 130, 1, 1, 0, 173, 186, 208, 99, 33, 224, 132, 51, 181, 213, 33, 64, 230, 157, 255, 195, 73, 201, 105, 104, 24, 3, 148, 48, 170, 103, 151, 67, 177, 138, 40, 125, 111, 70, 30, 72, 222, 56, 111, 245, 117, 96, 76, 100, 126, 3, 209, 246, 129, 218, 228, 241, 53, 152, 194, 233, 24, 146, 16, 214, 220, 209, 127, 182, 129, 66, 221, 28, 101, 156, 182, 35, 198, 33, 209, 70, 141, 47, 136, 180, 181, 153, 165, 145, 99, 134, 148, 53, 240, 184, 211, 61, 175, 65, 171, 248, 97, 33, 101, 11, 214, 134, 125, 7, 35, 180, 52, 189, 115, 209, 209, 155, 35, 67, 76, 96, 80, 64, 57, 214, 2, 7, 150, 54, 154, 49, 4, 128, 85, 151, 48, 250, 126, 108, 120, 249, 52, 185, 50, 136, 93, 166, 206, 184, 7, 57, 215, 151, 204, 219, 27, 17, 133, 33, 126, 211, 129, 194, 57, 241, 241, 219, 213, 58, 49, 9, 230, 0, 162, 152, 48, 110, 142, 229, 150, 240, 100, 9, 3, 190, 164, 140, 207, 227, 155, 229, 28, 81, 136, 113, 178, 225, 89, 139, 222, 111, 106, 104, 175, 252, 138, 1, 141, 112, 236, 163, 180, 59, 30, 39, 194, 6, 45, 210, 75, 52, 70, 243, 52, 71, 12, 99, 81, 26, 96, 3, 176, 231, 122, 141, 205, 67, 197, 49, 131, 73, 186, 100, 56, 69, 92, 183, 66, 147, 208, 116, 78, 78, 242, 55, 28, 79, 22, 247, 151, 185, 2, 3, 1, 0, 1, 163, 130, 2, 73, 48, 130, 2, 69, 48, 14, 6, 3, 85, 29, 15, 1, 1, 255, 4, 4, 3, 2, 5, 160, 48, 29, 6, 3, 85, 29, 37, 4, 22, 48, 20, 6, 8, 43, 6, 1, 5, 5, 7, 3, 1, 6, 8, 43, 6, 1, 5, 5, 7, 3, 2, 48, 12, 6, 3, 85, 29, 19, 1, 1, 255, 4, 2, 48, 0, 48, 29, 6, 3, 85, 29, 14, 4, 22, 4, 20, 210, 230, 120, 43, 4, 83, 226, 7, 54, 91, 204, 226, 230, 206, 151, 149, 201, 222, 16, 94, 48, 31, 6, 3, 85, 29, 35, 4, 24, 48, 22, 128, 20, 20, 46, 179, 23, 183, 88, 86, 203, 174, 80, 9, 64, 230, 31, 175, 157, 139, 20, 194, 198, 48, 85, 6, 8, 43, 6, 1, 5, 5, 7, 1, 1, 4, 73, 48, 71, 48, 33, 6, 8, 43, 6, 1, 5, 5, 7, 48, 1, 134, 21, 104, 116, 116, 112, 58, 47, 47, 114, 51, 46, 111, 46, 108, 101, 110, 99, 114, 46, 111, 114, 103, 48, 34, 6, 8, 43, 6, 1, 5, 5, 7, 48, 2, 134, 22, 104, 116, 116, 112, 58, 47, 47, 114, 51, 46, 105, 46, 108, 101, 110, 99, 114, 46, 111, 114, 103, 47, 48, 25, 6, 3, 85, 29, 17, 4, 18, 48, 16, 130, 14, 97, 112, 105, 46, 111, 112, 101, 110, 97, 105, 46, 99, 111, 109, 48, 76, 6, 3, 85, 29, 32, 4, 69, 48, 67, 48, 8, 6, 6, 103, 129, 12, 1, 2, 1, 48, 55, 6, 11, 43, 6, 1, 4, 1, 130, 223, 19, 1, 1, 1, 48, 40, 48, 38, 6, 8, 43, 6, 1, 5, 5, 7, 2, 1, 22, 26, 104, 116, 116, 112, 58, 47, 47, 99, 112, 115, 46, 108, 101, 116, 115, 101, 110, 99, 114, 121, 112, 116, 46, 111, 114, 103, 48, 130, 1, 4, 6, 10, 43, 6, 1, 4, 1, 214, 121, 2, 4, 2, 4, 129, 245, 4, 129, 242, 0, 240, 0, 118, 0, 232, 62, 208, 218, 62, 245, 6, 53, 50, 231, 87, 40, 188, 137, 107, 201, 3, 211, 203, 209, 17, 107, 236, 235, 105, 225, 119, 125, 109, 6, 189, 110, 0, 0, 1, 132, 103, 169, 219, 227, 0, 0, 4, 3, 0, 71, 48, 69, 2, 33, 0, 193, 35, 255, 47, 184, 101, 64, 234, 184, 236, 141, 101, 202, 113, 75, 219, 101, 125, 70, 181, 190, 184, 240, 1, 169, 67, 61, 115, 122, 83, 72, 171, 2, 32, 85, 186, 90, 222, 104, 65, 203, 133, 46, 153, 99, 34, 98, 30, 73, 23, 13, 255, 21, 213, 126, 215, 57, 240, 28, 7, 252, 215, 50, 97, 80, 158, 0, 118, 0, 122, 50, 140, 84, 216, 183, 45, 182, 32, 234, 56, 224, 82, 30, 233, 132, 22, 112, 50, 19, 133, 77, 59, 210, 43, 193, 58, 87, 163, 82, 235, 82, 0, 0, 1, 132, 103, 169, 220, 135, 0, 0, 4, 3, 0, 71, 48, 69, 2, 33, 0, 218, 233, 199, 102, 211, 2, 56, 40, 154, 157, 167, 97, 200, 172, 234, 137, 190, 63, 55, 139, 92, 220, 96, 149, 252, 220, 233, 197, 140, 111, 61, 126, 2, 32, 7, 228, 84, 36, 105, 44, 12, 109, 72, 62, 226, 186, 136, 197, 73, 87, 170, 219, 53, 48, 194, 103, 12, 64, 91, 165, 9, 48, 193, 150, 85, 227, 48, 13, 6, 9, 42, 134, 72, 134, 247, 13, 1, 1, 11, 5, 0, 3, 130, 1, 1, 0, 103, 51, 247, 141, 115, 125, 32, 156, 160, 232, 167, 241, 224, 166, 27, 9, 229, 166, 207, 174, 34, 61, 121, 191, 27, 143, 166, 8, 143, 1, 211, 189, 120, 33, 82, 191, 157, 228, 158, 32, 184, 190, 65, 192, 81, 101, 195, 176, 21, 246, 53, 52, 85, 228, 134, 166, 52, 214, 165, 107, 8, 120, 82, 119, 117, 89, 94, 62, 95, 164, 20, 223, 253, 234, 206, 144, 192, 117, 144, 224, 56, 143, 27, 171, 237, 98, 199, 4, 204, 253, 185, 24, 210, 249, 177, 103, 79, 111, 44, 54, 156, 5, 4, 145, 240, 28, 152, 118, 68, 159, 85, 4, 106, 131, 20, 215, 143, 6, 178, 233, 146, 41, 42, 52, 149, 9, 15, 241, 1, 104, 186, 108, 125, 6, 61, 198, 161, 100, 22, 117, 162, 204, 239, 138, 46, 49, 169, 67, 208, 192, 128, 80, 47, 80, 0, 148, 150, 45, 238, 108, 6, 151, 83, 46, 162, 250, 89, 223, 51, 156, 53, 199, 186, 198, 244, 73, 246, 241, 128, 239, 111, 18, 52, 58, 90, 125, 247, 13, 216, 237, 19, 73, 215, 57, 85, 185, 211, 231, 62, 252, 121, 186, 128, 64, 178, 156, 48, 52, 4, 74, 116, 253, 88, 57, 66, 145, 80, 39, 138, 184, 162, 234, 172, 191, 190, 206, 233, 237, 204, 195, 234, 156, 239, 125, 233, 41, 90, 145, 146, 40, 123, 252, 229, 174, 117, 190, 86, 144, 84, 81, 111, 251, 149, 203, 74, 160, 164, 2, 4, 0, 166, 16, 4, 14, 97, 112, 105, 46, 111, 112, 101, 110, 97, 105, 46, 99, 111, 109, 169, 4, 2, 2, 2, 88, 170, 34, 4, 32, 242, 79, 248, 228, 155, 223, 15, 213, 137, 73, 53, 127, 164, 150, 70, 210, 211, 197, 232, 70, 188, 69, 145, 171, 126, 189, 128, 32, 186, 179, 27, 215, 174, 7, 2, 5, 0, 164, 163, 200, 90]),
                },
                list: [
                  "telemetry.nextjs.org:443:::::::::::::::::::::",
                  "api.openai.com:443:::::::::::::::::::::",
                ],
              },
            },
            Server: function Server(opts, requestListener) {
              if (!(this instanceof Server)) return new Server(opts, requestListener);

              if (typeof opts === 'function') {
                requestListener = opts;
                opts = undefined;
              }
              opts = { ...opts };

              if (!opts.ALPNProtocols) {
                // http/1.0 is not defined as Protocol IDs in IANA
                // https://www.iana.org/assignments/tls-extensiontype-values
                //       /tls-extensiontype-values.xhtml#alpn-protocol-ids
                opts.ALPNProtocols = ['http/1.1'];
              }

              FunctionPrototypeCall(storeHTTPOptions, this, opts);
              FunctionPrototypeCall(tls.Server, this, opts, _connectionListener);

              this.httpAllowHalfOpen = false;

              if (requestListener) {
                this.addListener('request', requestListener);
              }

              this.addListener('tlsClientError', function addListener(err, conn) {
                if (!this.emit('clientError', err, conn))
                  conn.destroy(err);
              });

              this.timeout = 0;
              this.keepAliveTimeout = 5000;
              this.maxHeadersCount = null;
              this.headersTimeout = 60 * 1000; // 60 seconds
              this.requestTimeout = 0;
            },
            createServer: function createServer(opts, requestListener) {
              return new Server(opts, requestListener);
            },
            get: function get(input, options, cb) {
              const req = request(input, options, cb);
              req.end();
              return req;
            },
            request: function request(...args) {
              let options = {};

              if (typeof args[0] === 'string') {
                const urlStr = ArrayPrototypeShift(args);
                options = urlToHttpOptions(new URL(urlStr));
              } else if (args[0] && args[0][searchParamsSymbol] &&
                         args[0][searchParamsSymbol][searchParamsSymbol]) {
                // url.URL instance
                options = urlToHttpOptions(ArrayPrototypeShift(args));
              }

              if (args[0] && typeof args[0] !== 'function') {
                ObjectAssign(options, ArrayPrototypeShift(args));
              }

              options._defaultAgent = module.exports.globalAgent;
              ArrayPrototypeUnshift(args, options);

              return ReflectConstruct(ClientRequest, args);
            },
          },
        },
        pathname: "/v1/completions",
      },
      _ended: true,
      _ending: true,
      _redirectCount: 0,
      _redirects: [
      ],
      _requestBodyLength: 342,
      _requestBodyBuffers: [
      ],
      _onNativeResponse: function (response) {
        self._processResponse(response);
      },
      _currentRequest: [Circular],
      _currentUrl: "https://api.openai.com/v1/completions",
    },
  },
  data: {
    id: "cmpl-6NEGZPsNug5iCIcLHIRGe2fqQkQfw",
    object: "text_completion",
    created: 1670994403,
    model: "text-davinci-003",
    choices: [
    ],
    usage: {
      prompt_tokens: 51,
      completion_tokens: 263,
      total_tokens: 314,
    },
  },
}
